# 排列组合 

## 公式
```
A(4,2)=4x3=12
C(4,2)=4!/(2!x2!)=(4x3x2)/(2x2)=6
```

## 全排列-无脑for
```js
for (var i=0;i<len;i++) {
  for (var j=0;j<len;j++) {
    if (j!=i) {
      for (var k=0;k<len;k++) {
        if(k!=i && k!=j) {
          for (var l=0;l<len;l++) {
            if (l!=i && l!=j && l!=k) {
              newArray.push(strArray[i]+" "+strArray[j]+" "+strArray[k]+" "+strArray[l]);
            }
          }
        }
      }
    }
  }
}
```

## 全排列-递归
```js
// 《啊哈!算法》P73
function dfs (step) {
  if (step == n+1) { // 假如只有3个盒子,那么当step为4,指向第4个桶时,则打印并跳出
    let str = ""
    arrBox.map(value => {
      str = str + value
    })
  
    console.log (str)
    return 
  }

  for (let i = 1;i <= n;i++) {
    if (arrMark[i] == 0) { // for 以及 if 都是为了查找现在 arrBox 还剩哪些还没用
      arrBox[step] = i // 查找到当前还没用的数字, 将该数字放入当前的操作盒子里
      arrMark[i] = 1 // 在arrMark中标记已被使用的数字
      dfs(step + 1) // 进入下一盒子
      arrMark[i] = 0 // 假如所有数字都被使用了, 则执行当前行
    }
  }
  return
}

let n = 3
let arrBox = []
let arrMark = new Array(n+1).fill(0) // arrBox 的索引与值相等
dfs(1)
```

## 全排列 - 回溯
- 深度优先搜索 + 剪枝 = 回溯
- 代码一
  ```js
  function dfs(arr, index, len, temp) {
    if(index == len) {
      console.log(temp)
      return 
    }
    for(let i = 0;i < len; i++) {
      temp[index] = arr[i]
      if (isUseful(temp, index + 1)) {
        dfs(arr, index + 1, len, temp)
      }
    }

    // 剪枝, 一旦重复(['1', '2', '3'] 要求元素唯一), 则不再继续往下递归
    function isUseful(temp, cur) {
      for (let i = 0;i < cur;i++) {
        for (let j = i + 1; j < cur;j++) {
          if(temp[i] == temp[j]) return false
        }
      }
      return true
    }
  }

  let arr = ['1', '2', '3']
  dfs(arr, 0, arr.length, [])
  ```
- 代码二
  * 事后剪枝不够优雅,借助一个 hash 进行事前剪枝
  ```js
  function dfs(arr, index, len, temp, hash) {
    if(index == len) {
      console.log(temp)
      return 
    }
    for(let i = 0;i < len; i++) {
      if (!hash[i]) {
        hash[i] = true
        temp[index] = arr[i]
        dfs(arr, index + 1, len, temp, hash)
        hash[i] = false
      }
    }
  }

  let arr = ['1', '2', '3']
  dfs(arr, 0, arr.length, [], new Array(arr.length).fill(false))

  ```


## 参考
- [JS全排列的7种算法总结（不重复元素）](http://www.lingchenliang.com/post/134.html)
- [如何求ABC的全排列？--如何理解回溯算法？](https://segmentfault.com/a/1190000018771841?utm_source=tag-newest)