# 广度优先搜索

- 图算法可能是所有算法中最有用的
- BFS用于解决最短路径问题
- BFS一层一层搜索
- 最近一层称“一度空间”，倒数第二近称“二度空间”，依次类推......

## 可能用到的数据结构
* 图
  - 由节点与边组成
* 散列表/哈希表
  - 即JS中的Map，或用Object表示，形式是“键值对”
* 队列
  - BFS需要借助“队列”记录轨迹

## 树的BFS算法思路
### 例子(DOM结构中)
```html
<div id='root'>
  <span>123
    <a href="#">
      sdsd
    </a>
    <div>sdsd<a>这是一个a标签</a></div>
  </span>
  <span>456
    <p>这是一个p标签</p>
  </span>
</div>
```
```js
// 类似于 层序遍历
function wideTraversal(node) {  
  var nodes = [];  
  if (node != null) {  
    var queue = [];  
    queue.unshift(node);  
    while (queue.length != 0) {  
      var item = queue.shift();  
      nodes.push(item);  
      var children = item.children;  
      for (var i = 0; i < children.length; i++)  
        queue.push(children[i]);  
    }  
  }  
  return nodes;  
}
var root = document.getElementById('root');
console.log(wideTraversal(root)); 
```
### 概括
- 广度优先搜索/队列/先进先出/树
  * 第一步——根节点 A 入队
  * 第二部——队列 队首 A 出队
    - A 有子节点 ？ 子节点按顺序入队 ： 重复第2步(继续弹出队列队首)
- 深度优先搜索/栈/树 `(扩展)`
  * 第一步——根节点 A 入栈
  * 第二部——栈的栈顶 A 出栈
    - A 有子节点 ？ 子节点(BCD)按逆序入栈(B为栈顶) ： 重复第2步(继续弹出栈的栈顶)
```js
class Tree {
  constructor(data = []) {
    this.data = Array.from(data)
  }
  // 广度优先
  printBFS() {
    let str = ''
    let arr = []
    if (this.data === []) {
      return null
    }
    arr.push(this.data[0])
    getQueueHead()
    return str

    function getQueueHead() {
      if (arr.length === 0) {
        return
      }
      let head = arr.shift()
      str += head.value
      if (head.children !== undefined) {
        for (let i of head.children) {
          arr.push(i)
        }
      } 
      getQueueHead()
    }
  }
  // 深度优先
  printDFS() {
    let str = '', arr = []
    if (this.data === []) {
      return null
    } 
    arr.push(this.data[0])
    getStackTop()
    return str

    function getStackTop() {
      if (arr.length === 0) {
        return
      }
      let top = arr.pop()
      str += top.value
      if (top.children !== undefined) {
        top.children.reduceRight(function (pre, cur) {
          arr.push(cur)
        }, 0)
      }
      getStackTop()
    }
  }
}

// a的子节点:bcd；b的子节点：efg；d的子节点hi；f的子节点j；h的子节点k；j的子节点lmn
const tree = new Tree([{
  value: 'A',
  children: [{
    value: 'B',
    children: [{
      value: 'E'
    }, {
      value: 'F',
      children: [{
        value: 'J',
        children: [{
          value: 'L'
        }, {
          value: 'M'
        }, {
          value: 'N'
        }]
      }]
    }, {
      value: 'G'
    }]
  }, {
    value: 'C'
  }, {
    value: 'D',
    children: [{
      value: 'H',
      children: [{
        value: 'K'
      }]
    }, {
      value: 'I'
    }]
  }]
}])
console.log('广度优先遍历：')
console.log(tree.printBFS())
console.log('深度优先遍历：')
console.log(tree.printDFS())
```


## 图的BFS思路
- 创建一个队列Q。
- 将v标注为被发现的（灰色） ，并将v入队列Q。
- 如果Q非空，则运行以下步骤：
  * 将u从队列Q中取出
  * 将u标注为被发现的（灰色）
  * 将u所有未被访问过的邻节点（白色）加入队列
  * 将u标注为已被探索的（黑色）

### 例子
```js
function Graph() {
  var vertices = [];
  var adjList = new Dictionary();
  /*
   * @description 所有节点颜色初始化为白色
   * 白色——节点未被访问
   * 灰色——节点已经被访问，但未被探索
   * 黑色——节点已经被访问且被探索
   */
  var initializeColor = function(){
    var color = [];
    for (var i=0; i<vertices.length; i++) {
      color[vertices[i]] = 'white';
    }
    return color;
  };
  /*
   * @description 
   */
  this.bfs = function(v, callback) {
    var color = initializeColor(), // 将所有顶点初始化为白色
        queue = new Queue(); // 实例化队列
    queue.enqueue(v); // 将起始顶点v加入队列
    while (!queue.isEmpty()){ // 一直循环处理队列，直到队列为空
      var u = queue.dequeue(), // 移除队列顶部的元素，并取得该顶点
          neighbors = adjList.get(u); // 获取该顶点的相邻顶点
      color[u] = 'grey'; // 将该顶点置为灰色，表明该顶点被访问过，但并未被探索过
      for (var i=0; i<neighbors.length; i++){ // 循环处理该顶点的相邻顶点
        var w = neighbors[i];
        if (color[w] === 'white'){ // 如果该顶点没有被访问过
          color[w] = 'grey'; // 将该顶点置为灰
          queue.enqueue(w); // 将该顶点加入队列
        }
      }
      color[u] = 'black'; // 该顶点访问已经被完全访问，将其置为黑
      callback && callback(u); // 用回调函数处理该节点（如果有）
    }
  }
}
```

## 树的BFS思路3


## 参考
- [算法系列——JavaScript中广度优先搜索思想实现](https://segmentfault.com/a/1190000011983269)
- [学习JavaScript数据结构与算法 — 广度优先搜索算法](https://segmentfault.com/a/1190000011216377)
- [js对树的广度优先遍历和深度优先遍历](https://blog.csdn.net/zhanxinCBB/article/details/80926073)