# 散列表

## 哈希表
- 核心是确定映射关系
- 映射关系的确定：
  * 直接定址法：H(key)=key或H(key)=a·key+b
  * 数字分析法：对关键字进行分析，取关键字的若干位或其组合作哈希地址(适于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况)
  * 平方取中法：取关键字平方后中间几位作哈希地址(适于不知道全部关键字情况)
  * 折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）做哈希地址(适于关键字位数很多，且每一位上数字分布大致均匀情况)
(移位叠加、间界叠加)
  * 除留余数法：取关键字被某个不大于哈希表表长m的数p除后所得余数作哈希地址，即H(key)=key MOD p，p≤m
(p的选取很重要；p选的不好，容易产生同义词
一般情况下，可以选p为质数或不包含小于20的质因素的合数)
  * 随机数法：H(key)=random(key)适于关键字长度不等的情况

- 处理冲突的方法
  * 开放定址法
  * 再哈希法：若冲突,则后退一格;若还冲突,则后退2格;以此类推
  * 链地址法：若冲突,则冲突位置指向一个数组(数组内是所有冲突的元素)
  * 公共溢出区法


## 最简单的那种情形  
```js
function HashTable () {
	let table = []
	
	// 散列函数
	// 给定一个key参数(字符串类型)，我们就能根据组成key的每个字符的ASCII码值的和得到一个数字。
	let loseloseHashCode = function (key) {
		let hash = 0
		for (let i = 0;i < key.length;i++) {
			// 可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。
			hash += key.charCodeAt(i)
		}
		return hash % 37
	}
	
	this.put = function (key, value) {
		let position = loseloseHashCode (key)
		console.log (position + ' - ' + key)
		table[position] = value
	}
	
	this.remove = function (key) {
		table[loseloseHashCode(key)] = undefined
	}
	
	this.get = function (key) {
		return table[loseloseHashCode(key)]
	}
	
	this.print = function() { 
	  for (let i = 0; i < table.length; ++i) { 
			if (table[i] !== undefined) { 
				console.log(i + ": " + table[i])
			} 
		} 
	}
}
```
性能更佳的散列函数 djb2
```js
var djb2HashCode = function (key) {
  var hash = 5381;
  for ( let i = 0; i < key.length; i++) {
    hash = hash * 33 + key.charCodeAt(i);
  }
  return hash % 1013;
}
```