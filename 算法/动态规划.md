# 动态规划
- 本文是对`《算法图解》`中动态规划章节的总结
- 将问题拆分成小问题，再解决这些小问题, 解决的过程中需要记录这些小问题的答案  
- 动态规划一般都可以画网格来解决：
  * 网格的值表示什么
  * 网格的坐标轴表示什么
  * 该网格需解决的子问题是什么
- 网格的画法按`《算法图解》`，需要注意：
  * 判断能否“装入”当前商品？
    1. 能：Math.max(上一行背包, 当前物品价值 + 若背包大小为剩余空间大小时所能承受的最大价值)
    2. 否：上一行背包的价值
- 动态规划按行填充
- 动态规划的每个子问题独立，不能出现依赖关系，如：偷了笔记本时，吉他减重/吉他增值，不存在的

## 三个特征
- 最优子结构：只差一步即可解得最终答案的情况
- 边界：最简单的情况
- 状态转移方程：每一阶段与下一阶段之间的关系

## 方法
- 拆解问题
- 找状态转移方程
- 优先边界
- 完成

## 0-1背包
略

## 最长子串/最长子序列
- 子串是子序列的子集  
  如"abc"的子串之一是"ab",子序列之一是"ac"  
  以下坐标轴的方向都是：从方格网的左上角出发,分别往纵轴与横轴开始分布
- 最长公共子串
  * 坐标轴就是两个字符串的每一元素
  * 如果两个字母不同，值为0
  * 如果两个字母相同，值为左上角邻居的值加1
  * 最终获得的结果：
- 最长公共子序列
  * 坐标轴就是两个字符串的每一元素
  * 如果两个字母不同，值为Math.max(上方邻居值, 左方邻居值)
  * 如果两个字母相同，值为左上角邻居的值加1
  * 最终获得的结果：

## 动态规划练习

### 01背包问题
有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？  
```
200金/3人  
300金/4人  
350金/3人
400金/5人
500金/5人
```


### 阶梯问题
有n个阶梯，一个人每一步只能跨一个台阶或是两个台阶，问这个人一共有多少种走法？  
思路：
> 我们设置一个函数F(N)来表示走到第N级台阶走法的数量，现在假设有10级台阶。现在就会出现两种情况：  
> 我们是从第9级，跨1级上来，到第10级  
> 我们是从第8级，跨2级上来，到第10级  
> 其实对于任何第N级台阶，都会出现这两种情况，即第N级的前一步是走了1级或者两级。  
> 所以如果我们统计F(10)的话，可以发现F(10) = F(9) + F(8)，即到第10级的走法等于到第9级的走法加上到第8级的走法。  
> 所以我们就得到了动态规划步骤1中的所说的所谓的状态转移方程：F(N) = F(N-1) + F(N-2).  
```js
function climb (n) {
  let result = [0, 1, 2]
  if (n === 1 || n === 2) {
	return result[n]  
  } 
  for (let i = 3;i <= n;i++) {
	result[i] = result[i - 1] + result[i - 2]
  }
  return result[n]
} 
```

### 最大子序和
leetcode53. 最大子序和
```js

```

## 参考
- [漫画：什么是动态规划？](http://www.sohu.com/a/153858619_466939)
- [如何理解动态规划？](https://www.zhihu.com/question/39948290/answer/612439961)
- [LeetCode探索初级算法 - 动态规划](https://zhuanlan.zhihu.com/p/49427827)
- [《算法图解》]()
- [leetcode动态规划专题](https://leetcode-cn.com/tag/dynamic-programming/)
