# 对HTTP的改进
## 影响HTTP的因素
- 影响一个`HTTP`网络请求的因素主要有两个：带宽和延迟。
  * 带宽：5G时代到来使得带宽得到极大的提升，带宽不再是掣肘，影响因素就只剩下延迟了。
  * 延迟：
    - 浏览器阻塞（HOL blocking）：浏览器对于同一个域名，一般同时只能有4个连接，超过浏览器最大连接数限制，后续请求就会被阻塞。（因此才有部分资源换成不同域名的CDN）
    - DNS 查询（DNS Lookup）：将域名解析为 IP 的过程也会造成延迟。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。
    - 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。

## HTTP/0.9
已弃用，仅含一个请求方法`GET`

## HTTP/1.0 与 HTPP/1.1 的区别
- 缓存处理   
  HTTP/1.1提供了新的缓存策略(`Cache-Control`,`Etag 与 If-None-Match`)
- 带宽优化与网络连接的使用  
  HTTP/1.1支持只请求资源的某部分(状态码206)，以及断点续传
- 错误通知的管理  
  HTTP/1.1新增众多`4xx`的状态码
- 长连接  
  HTTP/1.1默认长连接(`Connection:keep-alive`或者`Connection:close`)

## HTTPS与HTTP/1.1的区别
- HTTPS = HTTP + 加密 + 认证 + 完整性保护  
  * HTTPS即运行在TLS/SSL上的HTTP。  
  * 人们希望数据在传输层是加密的，但在应用层是明文的，因此借助TLS/SSL在传输层对明文进行加密/解密  
  * 每个客户端/服务器都有自己的公钥/私钥，公钥用于加密，私钥用于解密  
  * 在建立安全传输之前，客户端与服务端之间需要互换公钥
  * 客户端发出请求：报文需要用服务器的公钥进行加密-->报文传输到服务器后用服务器的私钥进行解密  
    服务器返回响应：报文需要用客户端的公钥进行加密-->报文返回到客户端后用客户端的私钥进行解密
  * 公钥/私钥可能被窃听，如中间人攻击，在客户端/服务器交换公钥的过程，中间人假扮服务器/客户端。为此需要数字证书保证公钥来自服务器(即传输公钥前，客户端先获取服务器数字证书并向CA进行认证。数字证书可以由CA机构发布,也可以公司自己发布)
- HTTPS的加密分为：
  * 通信的加密：将http和SSL（安全套接层）或者TLS（安全传输层协议）组合使用，与SSL组合使用的HTTP被称为HTTPS（超文本传输安全协议）
  * 内容的加密：对明文进行加密
- 加密算法
  * 对称密钥：发送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算
  * 非对称密钥：非对称加密算法需要两个密钥：公开秘钥和私有密钥。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。
- HTTPS与HTTP区别：   
  1. HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
  2. HTTP 是不安全的，而 HTTPS 是安全的
  3. HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
  4. 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
  5. HTTP 无法加密，而HTTPS 对传输的数据进行加密
  6. HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书

## SPDY
当页面部分更新时，若重新加载页面显得不必要，因此有了Ajax技术  
但Ajax仍不够，还需要协议层面的改进，让HTTP加载资源更快。  
因此Google又研究了SPDY  
- SPDY没有改写HTTP协议，而是在TCP/IP的应用层与传输层之间以会话层形式运作，且表示层使用SSL
- SPDY的特点
  * HTTPS的特点
  * HTTP/2.0的特点
- SPDY与HTTP/2.0的区别
  * SPDY是HTTP/2.0的前身，HTTP/2.0是SPDY的升级版
  * SPDY与HTTP/2.0的首部压缩算法不同
  * HTTP/2.0支持明文传输,SPDY强制HTTPS

## WebSocket
SPDY仍是HTTP协议的改进，而WebSocket则是独立的新协议  
WebSocket特点
- WebSocket连接需要由客户端建立，一旦通信连接，任意一方都可以向对方发送报文
- WebSocket连接一旦建立便一直保持连接状态
- 首部字段更精简

## HTTP/2.0的改进
1. 多路复用  
   只需一个连接即可实现并行。HTTP/2引入"流"概念支持多路复用。(前端不必再合并资源了)
2. 服务器"推送"  
   允许服务端主动“推送”那些它认为客户端将会需要的内容到客户端的缓存中   
   比如：客户端浏览页面请求page.html，服务器在发回page.html后，认为客户端还需要JavaScript和CSS，则把strict.js和style.css也推送给客户端。  
   这一“推送”过程中服务器依然要遵循请求-响应这个模型，只不过服务器对同一请求可以推送多个响应。
3. 头部压缩
   HTTP/2协议使用了HPACK算法压缩头部，能显著压缩头部大小。
4. 优先级
   浏览器可以在发现资源时立即分派请求，指定每个流/资源的优先级，让服务器决定最优的响应次序。例如：HTML CSS 优先级高,JS 图片的优先级低

## HTTP2 多路复用理解
- 在 HTTP/1 中，每次请求都会建立一次TCP连接，也就是我们常说的3次握手4次挥手，这在一次请求过程中占用了相当长的时间，
- 即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：
  * 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
  * 第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6（Chrome），也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。
- HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。
- 多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。
- HTTP2中
  * 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。
  * 单个连接上可以并行交错的请求和响应，之间互不干扰

## HTTP/2.0的多路复用与HTTP/1.1的长连接的区别
> - HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
> - HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；


## 参考
- [HTTP1.0、HTTP1.1 和 HTTP2.0 的区别](https://www.cnblogs.com/heluan/p/8620312.html)
- [【小白学爬虫笔记】HTTP0.9 HTTP1.0 HTTP1.1 HTTP/2](https://www.jianshu.com/p/88326fa6dc92?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)
- [Http/2 升级指南](https://www.cnblogs.com/syyong/p/9088672.html)
- [通过 Node.js, Express.js 实现 HTTP/2 Server Push](https://www.jianshu.com/p/4b8983a78332)