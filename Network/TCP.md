# TCP
## OSI(Open Systems Interconncection，开放系统互联)网络分层
从上到下分别是：
- 应用层(Application)
- 表示层(Presentation)
- 会话层(Session)
- 传输层(Transport)
- 网络层(Network)    -- 路由器
- 数据链路层(Data Link) -- 交换机
- 物理层(Physical) -- 网卡、集线器（Hub）

## TCP携带的内容
1. tcp协议层是不关心ip的，具体ip的定位是由ip层来决定的，但是tcp层需要确定端口号，所以他会携带source 和 destination的port信息，以便能找到对应的端口号；
2. sequence number 实际中使用的SEQ，也就是序号，这个序号起了很重要的作用，我们都知道tcp和udp最大的区别在于tcp是稳定并且有序的，(`TCP在传输数据包时,并非一个个地传送,而是多个同时一起传输,因此需要保证数据的顺序`)其中seq就可以保证有序，当A向B发送一个数据包的时候，seq会叠加，每一个传输方在传送数据的时候都会带上这个信息，另一端能按照这个序号来排序收到信息的顺序，从未保证了信息的传递是有序的，也能通过它来确认有没有出现丢包的情况；另外要注意的是当有数据需要发送的时候，seq会随该序列号为原点，对自己将要发送的每个字节的数据进行编号，比如当前seq = 10，本次要发送的数据包大小是200字节，那么实际发送的时候会更新seq=210，以便保证传输的数据的顺序；
3. acknowledge number，实际中使用的ACK，是另一端对对方seq的一个回应，一般会把对方给的seq+1然后下一次发包的时候带上，这样的话对方就知道我们是收到前面的消息的；
4. windown代表的是滑动窗口，实际中用win来表示，win的大小很重要，win越大的传输越快，因为win的大小直接决定了某一端一次可以同时发送多少个数据包，而不用等待对方的应答ACK回来，但是win会随着每一个数据包的发送而变小(稍后解释)；
5. reserved 是tcp传输很重要的角色，标志位，响应方会根据对方给的信号执行对应的操作，比如执行断开连接的时候一般都是使用FIN标志位；

## 三次握手
- A：B，你好，我是A 请求建立连接，我的seq是0，我的win是65535，我希望本次回应我的内容长度len为0，我本次能接收的最大内容是1460，over；
- B：A，你也好，收到你的信息了，我是B，我本次的seq是0（注意，双方的序号是独立计算的，这里都从0开始的），我回应你的ack是1(A的seq+1，代表我收到你seq是0的消息了)，我的窗口大小是8192，我希望你回应我本次消息的len也是0，我这边能接收的最大回应大小是1452，over；
- A：好的，我收到你的回应了，我现在给你发送的seq是1(上一次是0，这次是1)，我回应你的ack是1(B的seq+1)，我当前的窗口大小是25984，我希望的回应长度是0；我们建立好连接了，over
- syn / syn + ack / ack
  
### 为什么不是1次,2次或4次
- 首先，1次肯定不行，1次的话 一方无法确认另一方的情况，所以最少都是2次起步，
- 2次：
  * A：喂喂喂，我是A，你听的到吗？
  * B：在在在，我能听到，我是B，你能听到我吗?
  * A：(听到了，老子不想理你)
  * B：喂喂喂？听不听到？我X，对面死了，我挂了。。
- 4次：
  * A：喂喂喂，我是A，你听的到吗？
  * B：在在在，我能听到，我是B，你能听到我吗?
  * A：听到了，你呢？你能听到吗？
  * B：？？你是智障？我不是说了我能听到吗，不想跟xx说话。。。

## 四次挥手
- 我们知道tcp的连接是全双工的
  * A和B是可以互相通信的，不理解的话，可以想想打电话（类比，不要当真），打电话的场景就是单双工的，因为同一时间只能一个人说话，另一个人听(`假设`)，如果2个人一起说话，那谁都听不清楚了，
  * 但是tcp是全双工的，就是A 正在给 B发信息的同时，B也在给A发信息，所以当断开的时候，必须要求双方都得知道，如果只有一方知道，肯定不行，因此，断开的时候，就需要4次挥手
  * ![TCP3次握手4次挥手](../assets/TCP3次握手4次挥手.PNG)

## 问题
### 为什么握手需要三次，而挥手却需要四次
- 握手的时候，A和B打个招呼，B可以直接把自己的SYN信息和对A的回应ACK信息一起带上;
- 但是挥手的时候，A说我要断开了，B还没发完最后的数据，因此需要先回应一下A，我收到你的断开的请求了，但是你要等我把最后的内容给你，所以这里分开了2步：
  * 回应A;
  * 发送自己的最后一个数据
### 网络本身是不稳定的,tcp是如何在尽可能少的时间内实现稳定和有序传输的(滑动窗口)
- SYN信息中会带上自己的seq，序号，这样可以保证另一方接受到后知道如何排序，
- 但是如果发送必须都是同步的，例如：
  * A 给 B发送的时候，需要给B 1，2，3，4，5个包，发了1后，死等1的ack回来，再给2，死等2的ack回来，
  * 在linux下每个tcp的timeout最大是2^5 - 1 = 63s
    - (默认的retrytime是5次)的时间，
    - 因为当发了一个包出去后，在一定时间内没收到ACK回应，为了确认不能丢包的问题，会启动重试机制，
    - 重试5次，它们的延迟分别是：1 秒、3 秒、7 秒、15 秒、31 秒，
    - 其中31s是前5次重试的时间1+2+4+8+16=31s，最后的32s是等待最后一次重试也超时(等待的时间是2的N次方秒)，所以一共就是63s，
    - 如果一个一个等，万一网络环境比较差，所以为了能在不丢包的情况下，尽量减少时间的损耗，引入了滑动窗口的概念，window
- 由于窗口由16位bit所定义，所以接收端TCP，窗口能最大提供65535个字节的缓冲，其实这个滑动窗口主要就是做限流和缓冲用的，
- 每一个tcp传输中的win提供的是对方的窗口大小，当A向B发数据的时候，超过B的win长度的数据会被丢掉，同时窗口还可以提高发送数据的效率，通过类似于并发的行为
### 滑动窗口介绍
- 早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。
- 滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包（称窗口尺寸）。
- TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。
- 当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，
  * 例如，允许用户终止在远端机上的运行进程。
  * 另一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。
### 丢包与快速超时重试机制
```
假如A给的分别是1，2，3，4到5 5个包，
B这边收到1，Ack一个2（代表收到1了），然后2丢了，3、4和5收到了，能直接ACK = 6吗？
```
这样的话tcp就是不稳定的了，考虑超时重传的2种方案：
1. timeout后只重新传2；
2. timeout后重新给2、3、4、5；
- 2种方案有好有坏，第一种比较慢，第二种浪费带宽，所以tcp引入了一种快速超时重试机制(Fast Retransmit算法)
  * 不以时间计算，而以数据做驱动重新传送，如果包没有连续到达，比如1到了，2没到，3，4，5也到了，这个时候，B始终返回ACK=2，代表只确认1，然后A就知道2没到，重新发2，
  * 但是B一旦收到2会直接ACK=6给A，这个的意思就是说2拿到后，345也收到了，直接给6就ok，
### DDos攻击
- tcp的握手环节是比较耗时的，当client端发起连接请求的时候，server端会回应，然后等待client的最终确认信息，默认情况下的linux会等待1到63s
- 这段时间内属于半连接的状态，服务器不会丢弃掉这些连接，而是会等
- 若攻击者客户端瞬间向服务器发起几千万个连接请求(SYN)，但对SYN-ACK不做回应(不返回ACK),让服务端处于等待状态(正常的用户无法访问)

## 参考
- [作为前端的你了解多少tcp的内容](https://juejin.im/post/5c078058f265da611c26c235)