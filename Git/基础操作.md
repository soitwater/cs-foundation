# 创建仓库

## 两种场景
- 把已有的项目代码纳入Git管理
  ```
  cd 项目目录
  git init
  ```
- 新建的项目直接使用Git管理
  ```
  git init your_project # 会在当前文件路径下创建与 your_project 同名的文件夹
  cd your your_project
  ```
## 接手一个Git仓库
```shell
git status               # 看当前仓库信息
# 若报误：Untracked files: 那么说明有些文件没有被 git管理到
git add . 
git commit -m "略略略"
git log                 # 查看git commit 历史
```
- git add .         // 从工作目录提交到暂存区
- git commit -m ""  // 保存记录到版本历史

## git重命名文件
```shell
git mv file_oldName file_newName # 重命名
```

## 查看版本历史
```shell
# 参数 --某某 是可以组合的
git log --oneline # 用简洁的方式展示 git log
git log -n1 # 只展示最近的一条 log 记录
git log # 默认仅查看当前分支的版本历史
git log [分支名] # 查看[分支名]分支的版本历史
git log --all # 查看所有分支的版本历史
git log --all --graph # 查看所有分支的版本历史(图形化的)
```
若分支混乱,想看版本历史,可以在工作目录下使用命令`gitk`

## git 对象
- commit  
  一个commit对应一颗tree(保存当时的文件快照)
- tree  
  tree即文件夹  
- blob  
  blob即文件(若文件内容相同,即为相同文件,它与文件名无关)
```shell
git log # 挑选一个版本历史(记住其hash值,至少4位)
git cat-file -p [hash (可以是 版本历史hash/tree哈希/blob哈希)] # 查看其中内容
git cat-file -p [hash (可以是 版本历史hash/tree哈希/blob哈希)] # 继续查看其中内容
```

## 分离头指针
分离头指针,可能导致`commit`内容因为不在分支上无法被追踪记忆等被孤立,很容易被git当做垃圾回收

## 分支
```shell
git branch # 查看分支
git branch -av # 查看分支(详细)
git checkout -b newBranchName # 创建新分支 newBranchName

git checkout -b [新分支名] origin/[旧分支名] # 创建本地分支
git push origin [新分支名] # 创建远程分支

git branch -d [分支名] # 删除分支
git branch -D [分支名] # 删除分支(在 -d 删除时,git会提示 -D 提示强制删除)
```

## HEAD
头指针,指向某一分支的某一次`commit`
```shell
git diff [commit hash] [commit hash] # 比较两次commit的差异
git diff [commit hash] [commit hash] -- [感兴趣的文件]  # 比较两次commit的所感兴趣的文件的差异
git diff HEAD HEAD~2 # 比较 HEAD提交与HEAD的父亲的父亲的提交的差异
git diff --cached # 比较暂存区与HEAD所含文件的差异
git diff # 默认比较工作区与暂存区的区别
git diff -- [文件名1 文件名2 文件名3] # 比较目标文件在 工作区 与 暂存区 的区别
```

## 修改git commit
- 修改`git commit`的message
```shell
git commit --amend # 进入后直接重写 commit 的提交消息
```
- 放弃暂存区保留的修改(暂存区变为工作区)
```shell
git reset HEAD # 恢复 暂存区 的变更(所有文件都放弃)为与 HEAD 一致
git reset HEAD -- [文件名1 文件名2 文件名3] # 恢复 暂存区 的变更(所指定的文件放弃)为与 HEAD 一致
```
- 将工作区恢复为暂存区
```shell
git checkout -- [文件名] # 不想要工作区的修改了,直接恢复到暂存区 
```
- 回退到某一次历史commit
```shell
git reset --hard [commit hash] # HEAD 与 暂存区 与 工作区 都回到历史某次 commit(不可恢复哦) 
```
  
## 删除文件
```shell
git rm [需要被删除的文件名] 
```

## 加塞紧急任务
```shell
git stash # 将当前的工作区的内容存放其他的地方,并清空当前工作区任务
git stash list # 查看被移动的工作区内容
git stash apply # 恢复被移动的原工作区内容到工作区,不会对丢失 stash 里保存的内容
git stash pop # 恢复被移动的原工作区内容到工作区,会丢失 stash 里保存的内容
```
## .gitignore
[可查看Github官方的示例](https://github.com/github/gitignore)

## Git的备份
即`git clone 链接`命令里的`链接`,`链接`分为哑协议(无协议头,速度慢,无进度展示)以及智能协议(`file:// https://`等)  

## SSH


## 提交
```shell
git pull  # 相当于 git fetch(将远端拉到本地), 再 git merge 啥??(将远端分支与当前分支合并)
git add .
git commit -m "略"
git push
```

## 在Github搜索
```shell
[关键字] in:readme
[关键字] starts:>1000
可以组合搜索
filename:[必须有文件名] # 如 filename:package.json
```

## rebase 与 merge 的区别
- rebase 与 merge 是实现相同功能的两种不同的方式
- merge 操作简单,rebase 操作有风险(会修改 commit 历史,因此禁止在'集成分支'上进行rebase操作)
- ```shell
  git checkout A
  git rebase B # 将 A分支上新增的 commit 以相同的方式再次在 B分支 上重现一次, 这些commit会直接跟在 B分支 后
  ```

## 补充
```shell
pwd # 当前文件夹路径
ls -al # 当前文件路径下的所有文件
vi ./git/config  # 查看 git config 
按一下esc, 再输入 :wq 回车 # 保存并退出 vi 编辑 (还有其他 不保存就退出等命令) 

mkdir [文件夹名称] # 新建文件夹

git status # 查看
git log # 查看版本历史
git help --web log # 再浏览器上查看 git log 的帮助信息 

# 报 Already up to date 时,可以尝试 使用命令 git pull

git rm [文件名] # 应用场景：删除暂存区的冲突文件
git add [文件名]
```