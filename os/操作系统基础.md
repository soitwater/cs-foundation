# 操作系统基础

操作系统基础
操作系统概述
	• 操作系统:指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。
	• 执行一个程序前需要将该程序放到内存中，才能被CPU处理
	• 没有软件支持的机器称为裸机,覆盖了软件的机器称为扩充机器or虚拟机
	• 操作系统的特征:
	• 操作系统提供的功能与目标：
		○ 资源的管理者
			§ 处理机管理
			§ 存储器管理
			§ 文件管理
			§ 设备管理
		○ 向上层提供方便易用的服务
			§ 用户可使用的
				□ GUI接口
				□ 命令接口
					® 联机命令接口 == 交互式命令接口(e.g.shell命令行; 特点:用户说一句,系统跟着做一句)
					® 脱机命令接口 == 批处理命令接口(e.g. *.bat 文件; 特点:用户先说一堆,系统再做一堆)
			§ 给程序员使用的
				□ 程序接口：即系统调用或广义指令(一般是程序员使用,如C语言的printf函数底层进行了系统调用)
		○ 对硬件机器的扩展
			§ 扩充机器or虚拟机
操作系统的特征
特征
	• 并发
		○ 指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。
		○ 常考易混概念——并行：指两个或多个事件在同一时刻同时发生。
	• 共享
		○ 共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。
		○ 两种资源共享方式
			§ 互斥共享方式
				□ 系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源
			§ 同时共享方式
				□ 系统中的某些资源，允许一个时间段内由多个进程'同时'对它们进行访问(宏观上同时,微观上分时共享)
	• 虚拟
		○ 背后的技术
			§ 空分复用技术：(虚拟存储器)电脑的物理内存是4GB,但却能运行2个运行内存需要4GB的游戏
			§ 时分复用技术：(虚拟处理器)电脑CPU只有单核，却能同时运行QQ、浏览器、QQ音乐等多个软件
	• 异步
		○ 理解：进程的执行不是一贯到底的，而是走走停停，，以不可预知的速度向前推进
理解
	• 操作系统的两个最基本特征：并发 + 共享，二者互为存在条件
		○ 没有并发，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了
		○ 没有并发，，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。
操作系统的发展与分类
发展与分类
	• 手工操作阶段
		○ 用户手动装入/取出纸条，效率远远低于计算机的计算效率
	• 批处理阶段
		○ 单道批处理系统
			§ 纸带换成了磁带,由监督程序控制输入/输出
			§ 效率增加，但不支持并发(串行运行),CPU 大量时间在等待I/O
		○ 多道批处理系统(操作系统开始出现)
			§ 计算机支持并发,共享
			§ CPU 保持忙碌状态
	• 分时操作系统
		○ 计算机以时间片为单位轮流为各个用户/作业服务
		○ 各个用户可通过终端与计算机进行交互。
		○ 主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。
		○ 主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。
	• 实时操作系统
		○ 能优先处理紧急任务(紧急任务无需排队)
		○ 可在严格的时限内处理完事件(及时性和可靠性)
		○ 分类
			§ 硬实时系统：在严格时间内完成处理(自动驾驶系统)
			§ 软实时系统：可接受偶尔超时完成(12306订票系统)
	• 网络操作系统
		○ 指多个计算机间通过网络连接，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信
	• 分布式操作系统
		○ 系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务(分布性和并行性)
	• 个人计算机操作系统
操作系统的运行机制
两种指令
	• 特权指令
		○ 如:内存清零指令
	• 非特权指令
		○ 应用程序只能使用“非特权指令”，如： 加法指令、减法指令等
	• 在CPU设计和生产的时候就划分了特权指令和 非特权指令，因此CPU 执行一条指令前就能判断出其类型
两种处理器状态
	• 核心态 == 内核态 == 管态
	• 用户态 == 目态
	• CPU 可以轻易判断指令类型,但它是如何判断当前运行的程序是内核程序or应用程序
		○ 处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令
		○ 处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令
	• CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示内核态，0表示用户态
	• 如何实现CPU状态的切换？
		○ 内核态 --> 用户态：执行一条特权指令 ——> 修改PSW的标志位为用户态，这个动作意味着操作系统将主动让出CPU使用权
		○ 用户态 --> 内核态：由中断引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权(除了非法使用特权指令之外，还有很多事件会触发中断信号。一个共性是，但凡需要操作系统介入的地方，都会触发中断信号)
	• 处理器状态流程
		○ 刚开机时，CPU 为内核态，操作系统内核程序先上CPU运行
		○ 开机完成后，用户可以启动某个应用程序
		○ 操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上CPU运行（操作系统内核在让出CPU之前，会用一条特权指令把 PSW 的标志位设置为用户态）
		○ 应用程序运行在用户态
		○ 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统
		○ CPU发现接下来要执行的这条指令是特权指令，但是自己又处于用户态
		○ 这个非法事件会引发一个中断信号（CPU检测到中断信号后，会立即变为核心态，并停止运行当前的应用程序，转而运行处理中断信号的内核程序）
		○ 中断使操作系统再次夺回CPU的控制权
		○ 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序
两种程序
	• 应用程序
		○ 普通程序员写的是应用程序
	• 内核程序
		○ 微软、苹果有一帮人负责实现操作系统，他们写的是内核程序 由很多内核程序组成了操作系统内核，或简称内核（Kernel）
		○ 内核是最接近硬件核心的部分
		○ 内核程序既可以执行特权指令，也可以执行非特 权指令，运行在核心态。
		○ 分类
			§ 时钟管理：实现计时功能
			§ 中断处理：负责实现中断机制
			§ 原语：
				□ 一种特殊的程序
				□ 是最接近硬件的部分
				□ 这种程序的运行具有原子性(一气呵成,不能中断)
				□ 运行时间短,调用频繁
			§ 对系统资源进行管理的功能：
				□ 进程管理
				□ 存储器管理
				□ 设备管理
中断和异常
中断的作用
	• 中断会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权，是让操作系统内核夺回CPU使用权的唯一途径
	• 如果没有中断机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序
中断的类型
	• 内中断(即异常)
		○ 分类
			§ 陷入
			§ 故障（由错误条件引起，可被内核程序修复，如缺页故障）
			§ 终止（由致命错误引起，内核程序无法修复，CPU会直接结束该应用程序，如除数为0）
		○ 与当前执行的指令有关， 中断信号来源于CPU内部
		○ 有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令
			§ 该指令会引发一个内部中断信号执行'陷入指令'，意味着应用程序主动地将CPU控制权还给操作系统内核。
			§ '系统调用'就是通过陷入指令完成
			§ 陷入指令 == 访管指令 == trap指令
	• 外中断(狭义的中断)
		○ 分类
			§ 时钟中断
			§ I/O中断
		○ 与当前执行的指令无关， 中断信号来源于CPU外部
		○ 每一条指令执行结束 时，CPU都会例行检查是否有外中断信号(如时钟中断每50ms由时钟部件发出中断信号)
中断机制的基本原理
	• 检查中断信号
		○ 内中断：CPU在执行指令时会检查是否有异常发生
		○ 外中断：每个指令周期末尾，CPU都会检查是否有外中断信号需要处理
	• 中断信号处理程序
		○ 不同的中断信号，需要用不同的中断处理程序来处理。
		○ 当CPU检测到中断信号后，会根据中断信号的类型去查询中断向量表，以此来找到相应的中断处理程序在内存中的存放位置。
系统调用
系统调用与库函数的区别
	• 应用程序调用库函数，库函数调用系统调用(部分库函数涉及系统调用,有的不涉及),系统调用调用操作系统的服务
为什么要用到系统调用
	• 凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。
系统调用的分类(按功能)
	• 设备管理：设备的请求/释放/启动
	• 文件管理：文件的读/写/创建/删除
	• 进程管理：进程的创建/撤销/阻塞/唤醒
	• 进程通信：进程之间的消息传递/信号传递
	• 内存管理：内存的分配/回收
系统调用的过程
	• 传递系统调用参数 --> 用户态下执行陷入指令 --> 核心态下执行相应的内请求核程序处理系统调用 --> 返回应用程序
	• 陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态
	• 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进
操作系统的体系
大内核/单内核/宏内核
	• 将操作系统的主要功能模块都作为系统内核，运行在核心态
	• 优点：高性能；缺点：内核代码庞大，结构混乱，难以维护
微内核
	• 只把最基本的功能保留在内核
	• 优点：内核功能少，结构清晰，方便维护；缺点：需要频繁地在核心态和用户态之间切换，性能低
非内核功能
	• Ubuntu、CentOS的开发团队，其主要工作是实现非内核功能(GUI等)，而内核都是用了Linux内核
进程的概念、组成、 特征
概念
	• 程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。
	• 进程（Process）：是动态的，是程序的一次执行过程(同一个程序多次执行会对应多个进程)
	• 一个进程实体(进程映像)由PCB、程序段、数据段组成。 进程是动态的，进程实体(进程映像)是静态的。进程实体反应了进程在某一时刻的状态(如：x++后，x=2)
	• 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
	• 一个进程被调度，即操作系统决定让这个进程上 CPU 运行
组成
	• PCB
		○ 进程描述信息
			§ 进程标识符 PID
			§ 用户标识符 UID
		○ 进程控制和管理信息
			§ CPU使用时间,磁盘使用状况,网络流量使用情况......
			§ 进程当前状态: 就绪态 / 阻塞态 / 运行态......
		○ 资源分配清单
			§ 正在使用哪些文件
			§ 正在使用哪些内存区域
			§ 正在使用哪些I/O设备
		○ 处理机相关信息
			§ 如 PSW, PC等等各种寄存器的值(用于进程切换)
	• 程序段
		○ 程序的代码(指令序列)
	• 数据段
		○ 运行过程中产生的各种数据(如：程序中定义的变量)
PCB
	• 操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中
	• PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。
	• 当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的'身份证号'——PID（ProcessID，进程ID
程序段 & 数据段
	• PCB是给操作系统用的。程序段、数据段是给进程自己用的。
	• 同时挂三个QQ号，会对应三个QQ 进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的(都是运行着相同的QQ程序)
程序是如何运行的
	• 一个程序开始运行前， 需要创建对应的进程， 也就要创建相应的PCB
	• 将程序段包(含程序指令)放入内存
	• CPU从内存中取出指令
	• 执行过程中会产生数据段(数据段: 包含运行过程中产生的各种数据)
进程的特征
	• 动态性(最基本的特征)：进程是程序的一次执行过程，是动态地产生、变化和消亡的
	• 并发性：内存中有多个进程实体，各进程可并发执行
	• 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位
	• 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供"进程同步机制”来解决异步问题
	• 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成
进程的组织
	• 进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题
	• 组织方式
		○ 链接方式
			§ 按照进程状态将PCB分为多个队列
			§ 操作系统持有指向各个队列的指针
		○ 索引方式
			§ 根据进程状态的不同，建立几张索引表
			§ 操作系统持有指向各个索引表的指针
链接方式
	• 执行指针
		○ 指向当前处于运行态(执行态)的进程
		○ 单CPU计算机中，同一时刻只会有一个进程处于运行态
	• 就绪队列指针
		○ 指向当前处于就绪态的进程
		○ 通常会把优先级高的进程放在队头
	• 阻塞队列指针
		○ 指向当前处于阻塞态的进程， 很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列
索引方式
	• 执行指针
	• 就绪表指针
		○ 指向就绪索引表
	• 阻塞表指针
		○ 指向阻塞索引表
进程的状态与转换
状态
	• 创建状态
		○ 操作系统会为进程分配资源、初始化PCB
	• 就绪状态
		○ 当进程创建完成后，便进入就绪态，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行
	• 运行状态
	• 阻塞状态
		○ 在进程运行的过程中，可能会请求等待某个事件的发生(如等待某种系统资源的分配，或者等待其他进程的响应).在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入阻塞态
		○ 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）
	• 终止状态
		○ 一个进程可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入终止态，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。
状态间的转换
	• 就绪态 --> 运行态
		○ 进程被调度
	• 运行态 --> 就绪态
		○ 时间片到，或CPU被其他高优先级的进程抢占
	• 运行态 --> 阻塞态
		○ 等待系统资源分配，或等待某事件发生（进程主动行为）
	• 阻塞态 --> 就绪态
		○ 资源分配就位，等待的事件发生（被动行为）
进程的组织方式(各个进程PCB的组织方式)
	• 进程PCB中，会有一个变量state来表示进程的当前状态。(如：1表示创建态、2表示就绪态、3表示运行态...)
	• 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。
	• 通常是链接方式以及索引方式
进程控制
	• 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。
如何实现进程控制
	• 用原语实现，原语是特殊的程序，它的执行具有原子性(执行过程一气呵成，不可中断)
	• 如果不能'一气呵成'，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作
	• 可以用 关中断指令和开中断指令这两个特权指令实现原子性
		○ (正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应 的中断处理程序)
		○ (CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查)
	• 进程控制实现原子性
进程控制相关的原语
	• 进程的创建
		○ 创建原语(操作系统创建一个进程时使用的原语)
			§ 申请空白PCB
			§ 为新进程分配所需资源
			§ 初始化PCB
			§ 将PCB插入就绪队列(创建态 --> 就绪态)
		○ 引进进程创建的条件
			§ 用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程
			§ 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程
			§ 提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求
			§ 应用请求：由用户进程主动请求创建一个子进程
	• 进程的终止
		○ 撤销原语(就绪态 / 阻塞态 / 运行态 --> 终止态 )
			§ 从PCB集合中找到终止进程的PCB
			§ 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
			§ 终止其所有子进程(进程间的关系是树形结构)
			§ 将该进程拥有的所有资源归还给父进程或操作系统
			§ 删除PCB
		○ 引起进程终止的事件
			§ 正常结束（进程自己请求终止:exit系统调用）
			§ 异常结束（整数除以0、非法使用特权指令等）
			§ 外界干预（用户打开任务管理器杀掉进程）
	• 进程的阻塞和唤醒(阻塞原语以及唤醒原语都应该成对使用)
		○ 进程的阻塞
			§ 阻塞原语
				□ 找到要阻塞的进程对应的PCB
				□ 保护进程运行现场，将PCB状态信息设置为阻塞态，暂时停止进程运行
				□ 将PCB插入相应事件的等待队列
			§ 引起进程阻塞的事件
				□ 需要等待系统分配某种资源
				□ 需要等待相互合作的其他进程完成工作
		○ 进程的唤醒
			§ 唤醒原语
				□ 在事件等待队列中找到PCB
				□ 将PCB从等待队列移除，设置进程为就绪态
				□ 将PCB插入就绪队列，等待被调度
			§ 引起进程唤醒的事件
				□ 等待的事件发生（因何事阻塞，就应由何事唤醒）
		○ 进程的切换
			§ 切换原语（就绪态与运行态之间的相互切换）
				□ 将进程上下文存入PCB
				□ PCB移入相应队列
				□ 选择另一个进程执行，并更新其PCB
				□ 根据PCB恢复新进程所需的运行环境
			§ 引起进程切换的事件
				□ 当前进程时间片到达
				□ 有更高优先级的进程到达
				□ 当前进程主动阻塞
				□ 当前进程终止
	• 无论哪个进程控制原语，要做的无非三类事情
		○ 更新PCB中的信息
			§ 所有的进程控制原语一定都会修改进程状态标志
			§ 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
			§ 某进程开始运行前必然要恢复期运行环境
		○ 将PCB插入合适的队列
		○ 分配/回收资源
进程通信
概念
	• 进程通信就是指进程之间的信息交换。
	• 各进程拥有的内存地址空间相互独立。
	• 为了保证安全，一个进程不能直接访问另一个进程的地址空间，只能通过共享传递,消息传递,管道通信
共享传递
	• 两个进程对共享空间的访问必须是互斥的
	• 分类
		○ 基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式
		○ 基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。
消息传递
	• 进程间的数据交换以格式化的消息Message为单位。进程通过操作系统提供的发送消息/接收消息两个原语进行数据交换。
	• 传递的消息是结构化的，含消息头,消息体
		○ 消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的报文其实就是一种格式化的消息）
	• 两种方式
		○ 直接通信方式：消息直接挂到接收方的消息队列中
		○ 间接通信方式：消息先发到中间体(信箱通信方式)
管道通信
	• 管道是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区
	• 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道
	• 各进程要互斥地访问管道。
	• 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
	• 如果没写满，就不允许读。如果没读空，就不允许写
	• 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况
线程的概念和特定
进程与线程
	• 进程是资源分配的基本单位
	• 当切换进程时，需要保存/恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）开销很大
	• 引入线程后，线程是CPU调度的基本单位,线程也有运行态、就绪态、阻塞态
	• 进程依然是资源分配的基本单位。从属于同一进程的各个线程共享进程的资源
为什么需要线程
	• 进程间并发，开销很大;线程间(在同一进程中)并发，开销更小
	• 当切换进程时，必须请求操作系统服务（CPU要切换到核心态），需要保存/恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）
	• 同一进程内的各个线程间并发，无需操作系统干预，不需要切换进程运行环境和内存地址空间，省时省力
线程的特性
	• 线程是CPU调度的基本单位,线程也有运行态、就绪态、阻塞态
	• 多cpu计算机中，各个线程可占用不同的cpu
	• 每个线程都有一个线程ID、线程控制块(TCB)
	• 线程几乎不拥有资源，只拥有极少量的资源（线程控制块TCB、寄存器信息、堆栈等）
线程的实现
	• 用户级线程(从用户视角看能看到的线程)
		○ 用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）
		○ 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
		○ 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明）
	• 内核级线程(从操作系统内核视角看能看到的线程)
		○ 内核级线程的管理工作由操作系统内核完成。
		○ 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
		○ 操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位
		○ 例如：
			§ 某系统中，有一进程由两个内核级线程，三个用户级线程，将三个用户级线程映射到两个内核级线程。
			§ 在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。
	• 多线程模型
		○ 多对一
			§ 多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程
			§ 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
			§ 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行
		○ 一对一
			§ 一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。
			§ 优点：当一个线程被阻塞后，别的线程还可 以继续执行，并发能力强。多线程可在多核 处理机上并行执行。
			§ 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
		○ 多对多
			§ n用户及线程映射到m个内核 级线程（n>=m）。每个用户进程对应m个内核级线程。
			§ 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。
处理机调度概念以及层次
概念
	• 在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。
调度的三个层次
	• 高级调度(作业调度)( 无 --> 创建态 --> 就绪态)
		○ 由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。
		○ 高级调度(作业调度)按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使它（们）获得竞争处理机的权利。
		○ 高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。
		○ 高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。
	• 中级调度(内存调度)(挂起态 --> 就绪态或者阻塞挂起 --> 阻塞态)
		○ 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。
		○ 暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。
		○ PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。
		○ 中级调度就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。
	• 低级调度(进程调度)(就绪态 --> 运行态)
		○ 低级调度其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。
		○ 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。
		○ 进程调度的频率很高，一般几十毫秒一次。
进程的挂起态与七状态模型(5 + 2)
	• 暂时调到外存等待的进程状态为挂起态(挂起态,suspend) 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态
	• 挂起和阻塞的区别
		○ 两种状态都是暂时不能获得CPU的服务
		○ 但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。
进程调度的时机，切换与过程，调度方式
时机
	• 进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机
	• 需要进行进程调度与切换的情况
		○ 当前运行的进程主动放弃处理机
			§ 进程正常终止
			§ 运行过程中发生异常而终止
			§ 进程主动请求阻塞（如:等待I/O）
		○ 当前运行的进程被动放弃处理机
			§ 分给进程的时间片用完
			§ 有更紧急的事需要处理（如I/O中断）
			§ 有更高优先级的进程进入就绪队列
	• 不能进行进程调度与切换的情况
		○ 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
		○ 进程在操作系统内核程序临界区中。
		○ 在原子操作过程中（原语）原子操作不可中断，要一气呵成（如 修改PCB中进程状态标志，并把PCB放到相应队列）
调度方式
	• 非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
		○ 实现简单，系统开销小但是无法及时处 理紧急任务，适合于早期的批处理系统
	• 剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。
		○ 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统
进程的切换与过程
	• 狭义的进程调度与进程切换的区别
		○ 狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）
		○ 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。
	• 广义的进程调度包含了选择一个进程和进程切换两个步骤。
	• 进程切换的过程主要完成了
		○ 对原来运行进程各种数据的保存
		○ 对新的进程各种数据的恢复 （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）
	• 注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低， 使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。
调度算法的评价指标
CPU利用率
	• 指CPU忙碌的时间占总时间的比例
系统吞吐量
	• 单位时间内完成作业的数量
周转时间
	• 周转时间
		○ 周转时间=作业完成时间–作业提交时间
		○ 从作业被提交给系统开始，到作业完成为止的这段时间间隔。
		○ 它包括四个部分(后三项在一个作业的整个处理过程中，可能发生多次)：
			§ 作业在外存后备队列上等待作业调度（高级调度）的时间
			§ 进程在就绪队列上等待进程调度（低级调度）的时间
			§ 进程在CPU上执行的时间、
			§ 进程等待I/O操作完成的时间
	• 带权周转时间
		○ 带权周转时间 = 作业周转时间 - 作业实际运行的时间
等待时间
	• 指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低
	• 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。
	• 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。
	• 一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间
响应时间
	• 指从用户提交请求到首次产生响应所用的时间
调度算法
先来先服务(FCFS)
	• 算法思想
		○ 公平（类似于生活中排队买东西）
	• 算法规则
		○ 按照作业/进程到达的先后顺序进行服务
	• 用于作业/进程调度
		○ 用于作业调度时，考虑的是哪个作业先到达后备队列；
		○ 用于进程调度时，考虑的是哪个进程先到达就绪队列
	• 是否可抢占
		○ 非抢占式的算法
	• 优缺点
		○ 优点：公平、算法实现简单
		○ 缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。 即，FCFS算法对长作业有利，对短作业不利
	• 是否会导致饥饿(某进程/作业长期得不到服务)
		○ 不会
短作业优先(SJF / SPF)
	• 算法思想
		○ 追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间
	• 算法规则
		○ 最短的作业/进程优先得到服务（所谓最短，是指要求服务时间最短）
	• 用于作业/进程调度
		○ 即可用于作业调度，也可用于进程调度。
		○ 用于进程调度时称为短进程优先（SPF,ShortestProcessFirst）算法
	• 是否可抢占
		○ SJF和SPF是非抢占式的算法。
		○ 但是也有抢占式的版本——最短剩余时间优先算法（SRTN,ShortestRemainingTimeNext）
	• 优缺点
		○ 优点：“最短的”平均等待时间、平均周转时间
		○ 缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先
	• 是否会导致饥饿
		○ 会
		○ 如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为饿死
高响应比优先(HRRN)
	• 算法思想
		○ 要综合考虑作业/进程的等待时间和要求服务的时间
	• 算法规则
		○ 在每次调度时先计算各个作业 or 进程的响应比((等待时间 + 要求服务时间) / 要求服务时间)，选择响应比最高的作业 or 进程为其服务
	• 用于作业/进程调度
		○ 即可用于作业调度，也可用于进程调度
	• 是否可抢占
		○ 非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比
	• 优缺点
		○ 上述两种算法(FCFS与SJF / SPF)的权衡折中,综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先（SJF的优点）要求服务时间相同时，等待时间长的优先（FCFS的优点） * 对于长作业来说，随着等待时间越来越久，其响应比也会 越来越大，从而避免了长作业饥饿的问题
	• 是否会导致饥饿
		○ 不会
时间片轮转
	• 算法思想
		○ 公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
	• 算法规则
		○ 按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队
	• 用于作业/进程调度
		○ 用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）
		○ 若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到
	• 是否可抢占
		○ 若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到
	• 优缺点
		○ 优点：公平；响应快，适用于分时操作系统；
		○ 缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。
	• 是否会导致饥饿
		○ 不会
优先级调度
	• 算法思想
		○ 随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序
	• 算法规则
		○ 调度时选择优先级最高的作业/进程
	• 用于作业/进程调度
		○ 既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中
	• 是否可抢占
		○ 抢占式、非抢占式都有。区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占
	• 优缺点
		○ 优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。
		○ 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿
	• 是否会导致饥饿
		○ 会
多级反馈队列
	• 算法思想
		○ 对其他调度算法的折中权衡
	• 算法规则
		○ 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
		○ 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。
		○ 如果此时已经是在最下级的队列，则重新放回该队列队尾
		○ 只有第k级队列为空时，才会为k+1级队头的进程分配时间片
	• 用于作业/进程调度
		○ 用于进程调度
	• 是否可抢占
		○ 抢占式的算法。
		○ 在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。
	• 优缺点
		○ 对各类型进程相对公平（FCFS的优点）；
		○ 每个新到达的进程都可以 很快就得到响应（RR的优点）；
		○ 短进程只用较少的时间就可完成 （SPF的优点）；
		○ 不必实现估计进程的运行时间（避免用户作假）；
		○ 可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密 集型进程
		○ （拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）
	• 是否会导致饥饿
		○ 会
进程同步与进程互斥
进程同步
	• 进程具有异步性的特征(各并发执行的进程以各自独立的、不可预知的速度向前推进)
	• 同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系(如：A指令必须发生在B指令之前)
进程互斥
	• 进程的并发需要共享的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I/O设备）
	• 一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都 属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。
	• 对临界资源的访问，必须互斥地进行。
		○ 互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。
		○ 当前访问临界资源的进程访问结束，释放该资源之后， 另一个进程才能去访问临界资源。
	• 临界区是进程中访问临界资源的代码段。进入区和退出区是负责实现互斥的代码段
	• 四个部分
		○ 进入区：检查是否可进入临界区，若可，需要上锁
		○ 临界区：访问临界资源的那段代码
		○ 退出区：负责解锁
		○ 剩余区：其余代码部分
	• 为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：
		○ 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；
		○ 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
		○ 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
		○ 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。
进程互斥的软件实现方法
单标志法
	• 算法思想
		○ 一个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予(进入区 --> 临界区 --> 退出区 --> 剩余区)
		○ 缺点
			§ 违背空闲让进原则
			§ 例如：一个进程P0访问资源，此时P0被允许进入临界区，但是P0一直不访问临界区，那么此时临界区空闲，但是其他资源无法访问
双标志先检查法
	• 算法思想
		○ 设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如 flag[0]=ture意味着0号进程P0现在想要进入临界区。
		○ 每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。
	• 缺点
		○ 违反忙则等待原则
		○ 进入区的检查和上锁 两个处理不是一气呵成的。检查后，上锁前可能发生进程切换。
双标志后检查法
	• 算法思想
		○ 双标志先检查法的改版。前一个算法的问题是先检查后上锁，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。
		○ 因此，人们又想到先上锁后检查的方法，来避免上述问题
	• 缺点
		○ 虽然解决了忙则等待的问题，但是又违背了空闲让进和有限等待
		○ 会因各进程都长期无法访问临界资源而产生饥饿现象。两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区
Peterson算法
	• 算法思想
		○ 结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试孔融让梨(谁最后说客气话,谁就失去了主动权)
	• 缺点
		○ Peterson 算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则
		○ 但是依然未遵循让权等待的原则。
进程互斥的硬件实现方法
中断屏蔽方法
	• 实现
		○ 利用开/关中断指令实现
		○ 步骤是:关中断 --> 临界区 --> 开中断
			§ 关中断后即不允许当前进程被中断，也必然不会发生进程切换，因此也不可能发生两个同时访问临界区的情况
			§ 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区
	• 优点
		○ 简单、高效
	• 缺点
		○ 不适用于多处理机
		○ 只适用于操作系统内核进程
		○ 不适用于用户进程(因为开/关中断指令只能运行在内核态)
TestAndSet指令(TS指令 或 TestAndSetLock指令 或 TSL指令)
	• TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成
	• 算法

bool TS(bool *lock) {
  bool old;
  old = *lock;
  *lock = true;
  return old;
}
while(TS(&lock)); // 上锁并`检查`
// 临界区代码段
lock = false;
// 剩余区代码段 (解锁)
		○ 若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。
		○ 若刚开始lock是true，则执行TLS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行解锁
	• 相比软件实现方法，TSL指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作。
	• 优点
		○ 实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞
		○ 适用于多处理机环境
	• 缺点
		○ 不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等
Swap指令（Exchange指令 或 XCHG指令）
	• Swap指令与TSL指令逻辑类似，都是：
		○ 记录临界区是否已经上锁(记录在 old 变量上)，再将上锁标记设为 true
		○ 最后检查 old，如果old为false (解锁了)，此时可跳出循环，进入临界区
	• 代码

Swap (bool *a, bool *b) {
  bool temp;
  temp = *a;
  *a = *b;
  *b = temp;
}
// Swap 指令
bool old = true;
while (old == true)
  Swap(&lock, &old);
// 临界区代码段
lock = false
// 剩余区代码段
	• 优缺点同TSL指令
信号量机制
	• 信号量机制(记录型)是更有效的进程互斥、同步的方法
	• 信号量其实就是一个变量
		○ 可以用一个信号量来表示系统中某种资源的数量
		○ 信号量的值=这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）
		○ 比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。
	• 原语由关中断/开中断指令实现，强调执行的一气呵成，类似于函数.
	• 一对原语：即wait(S)原语和signal(S)原语,也写作P(S)和V(S),P是申请资源,V是释放资源,此处可以将原语理解为函数,括号内的S即为信号量,表示传入函数的参数
信号量分类
	• 整型信号量
		○ 用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。 Eg：某计算机系统中有一台打印机
		○ 缺陷：忙等
		○ 代码

int S = 1 // 初始化信号量

void wait(int S) { // wait 原语,相当于'进入区'
  while(S <= 0); // 如果资源数量不够,则一直循环等待
  S = S - 1; // 资源数量够,则占用一个资源
}

void signal(int S) { // signal 原语，相当于'退出区'
  S = S + 1; // 使用完资源后，在退出区释放资源
}
	• 记录型信号量
		○ 代码

// 记录型信号量定义
typedef struct {
  int value; // 剩余资源数
  struct process *L; // 等待队列
} semaphore;
// 某进程通过wait 原语申请进程
void wait (semaphore S) {
  S.value --;
  // 资源用完了，主动进入阻塞态，遵循了`让权等待`原则，不会出现`忙等`
  if(S.value < 0) {
    // 如果剩余资源数不够， 使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中
    block(S.L);
  }
}
// 某进程使用完进程后，通过signal 原语释放
void signal(semaphore S) {
  S.value++;
  // 假如释放完资源后记录型信号量仍是 <= 0，说明还有资源在等待资源，应去等待队列中唤醒它
  if(S.value <= 0) {
    // 释放资源后，若还有别的进程在等待这种资源，则使用 wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
    wakeup(S.L); 
  }
}
用信号量机制实现进程互斥、同步、前驱关系
实现进程互斥
	• 即记录型信号量
		○ 设置临界区
		○ 设置互斥信号量，初始值为1
		○ 临界区之前对信号量执行P操作
		○ 临界区之后对信号量执行V操作
实现进程同步
	• P2的执行需要某种资源S， 而资源S又只能由P1产生
	• 口诀前V后P
		○ 设置同步信号量S,初始为0
		○ 在前操作之后执行V(S)
		○ 在后操作之前执行P
实现前驱关系
	• 本质上是多级同步问题
		○ 进程P1中有句代码S1，P2中有句代码S2，P3中有句代码S3......P6中有句代码S6
		○ 要求执行S6前需执行S3,S4,S5;执行S3前需要执行S1......
	• 步骤
		○ 为每一对前驱关系各设置一个同步信号量
		○ 在前操作之后对相应的同步信号量执行V操作
		○ 在后操作之前对相应的同步信号量执行P操作
进程问题
生产者消费者问题
	• 即有限缓冲问题，是一个多线程同步问题的经典案例
	• 问题
		○ 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。
		○ 生产者、消费者共享一个初始为空、大小为n的缓冲区。
		○ 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。
		○ 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。
		○ 缓冲区是临界资源，各进程必须互斥地访问
	• 问题的关键
		○ 保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。
		○ 必须让生产者在缓冲区满时休眠，等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。
		○ 同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。
		○ 通常采用进程间通信的方法解决该问题。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己
	• 伪代码

var items = 0 // 代表缓冲区已经使用的资源数
var space = 10 // 代表缓冲区可用资源数
var mutex = 1 // 互斥锁,即互斥信号量
var in = 0, out = 0; // 代表第一个资源和最后一个资源
item buf[10] = { NULL }; // 代表缓冲区，其内容类型为item

producer {
  while( true ) {
    wait( space );  // 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前
    wait( mutex );  // 保证在product时不会有其他线程访问缓冲区

// product
    buf.push( item, in );  // 将新资源放到buf[in]位置 
    in = ( in + 1 ) % 10;
    
    signal( mutex );  // 唤醒的顺序可以不同
    signal( items );  // 通知consumer缓冲区有资源可以取走
  }
}

consumer {
  while( true ) {
    wait( items );  // 等待缓冲区有资源可以使用
    wait( mutex );  // 保证在consume时不会有其他线程访问缓冲区

// consume
    buf.pop( out );  // 将buf[out]位置的的资源取走
    out = ( out + 1 ) % 10;

signal( mutex );  // 唤醒的顺序可以不同
    signal( space );  // 通知缓冲区有空闲位置
  }
}

多生产者多消费者问题
		○ 问题
			§ 桌子上有一只盘子，每次只能向其中放入一个水果。
			§ 爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。
			§ 只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。
			§ 用PV操作实现上述过程。
	• 解题思路
		○ 关系分析找：出题目中描述的各个进程，分析它们之间的同步、互斥关系。(互斥是VP,同步是前V后P)
		○ 整理思路：根据各进程的操作流程确定P、V操作的大致顺序。
		○ 设置信号量：设置需要的信号量，并根据题目条件确定信号量初值(互斥信号量初值一般为1,同步信号量的初始值要看对应资源的初始值)
	• 代码

semaphore mutex = 1; //实现互斥访问盘子（缓冲区） 
semaphore apple = 0; //盘子中有几个苹果 
semaphore orange = 0; //盘子中有几个橘子 
semaphore plate = 1; //盘子中还可以放多少个水果

dad () { 
  while(1) { 
    准备一个苹果; 
    P(plate); 
    P(mutex); 
    把苹果放入盘子; 
    V(mutex); 
    V(apple); 
  } 
}

mom () { 
  while(1) { 
    准备一个橘子; 
    P(plate); 
    P(mutex); 
    把橘子放入盘子; 
    V(mutex); 
    V(orange); 
  } 
}

daughter () {
  while(1) { 
    P(apple); 
    P(mutex); 
    从盘中取出苹果; 
    V(mutex); 
    V(plate); 
    吃掉苹果; 
  }
}

son () {
  while(1) { 
    P(orange); 
    P(mutex); 
    从盘中取出橘子; 
    V(mutex); 
    V(plate); 
    吃掉橘子; 
  }
}
吸烟者问题
	• 本质是可生产多种产品的单生产者-多消费者问题
	• 问题
		○ 假设一个系统有三个抽烟者进程和一个供应者进程。
		○ 每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。
		○ 一个抽烟的有烟草，另一个有纸，第三个有胶水。
		○ 供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉完成了，供应者就会放另外两种材料在桌上
		○ 这种过程一直重复(让三个抽烟者轮流地抽烟)。
		○ 请用信号量及PV操作实现这四个进程的并发执行。
	• 解题

semaphore offer1 = 0; //桌上组合一的数量 
semaphore offer2 = 0; //桌上组合二的数量 
semaphore offer3 = 0; //桌上组合三的数量 
semaphore finish = 0; //抽烟是否完成 
int i = 0; //用于实现`三个抽烟者轮流抽烟`

provider () { 
  while(1) { 
    if(i==0) { 
      将组合一放桌上; 
      V(offer1); 
    } else if(i==1) { 
      将组合二放桌上; 
      V(offer2); 
    } else if(i==2){ 
      将组合三放桌上; 
      V(offer3); 
    } 
    i = (i+1)%3; 
    P(finish); 
  } 
}

smoker1 () { 
  while(1) { 
    P(offer1); 
    从桌上拿走组合一;
    卷烟;
    抽掉;
    V(finish); 
  } 
}  

smoker2 () { 
  while(1) { 
    P(offer2); 
    从桌上拿走组合二;
    卷烟;
    抽掉;
    V(finish); 
  } 
}

smoker3 (){ 
  while(1){ 
    P(offer3); 
    从桌上拿走组合三;
    卷烟;
    抽掉; 
    V(finish); 
  } 
}
读者写者问题
	• 问题
		○ 有读者和写者两组并发进程，共享一个文件
		○ 当两个或以上的读进程同时访问共享数据时不会产生副作用
		○ 但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。
		○ 因此要求
			§ 允许多个读者可以同时对文件执行读操作
			§ 只允许一个写者往文件中写信息
			§ 任一写者在完成写操作之前不允许其他读者或写者工作
			§ 写者执行写操作前，应让已有的读者和写者全部退出
	• 问题分析
		○ 关系分析
			§ 由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。
		○ 整理思路
			§ 写者进程比较简单，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。
			§ 读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。
				□ 那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。
				□ 当有读者的时候写者是无法写文件的，此时读者会一直占用文件
				□ 当没有读者的时候写者才可以写文件。
				□ 同时这里不同读者对计数器的访问也应该是互斥的。
		○ 信号量设置
			§ 首先设置信号量count为计数器，用来记录当前读者数量，初值为0;
			§ 设置mutex为互斥信号量，用于保护更新count变量时的互斥
			§ 设置互斥信号量rw用于保证读者和写者的互斥访问
	• 代码

int count=0;  //用于记录当前的读者数量
semaphore mutex=1;  //用于保护更新count变量时的互斥
semaphore rw=1;  //用于保证读者和写者互斥地访问文件
writer () {  //写者进程
  while (1){
    P(rw); // 互斥访问共享文件
    Writing;  //写入
    V(rw) ;  //释放共享文件
  }
}
 reader () {  // 读者进程
  while(1){
    P (mutex) ;  //互斥访问count变量
    if (count==0)  //当第一个读进程读共享文件时
      P(rw);  //阻止写进程写
    count++;  //读者计数器加1
    V (mutex) ;  //释放互斥变量count
    reading;  //读取
    P (mutex) ;  //互斥访问count变量
    count--; //读者计数器减1
    if (count==0)  //当最后一个读进程读完共享文件
      V(rw) ;  //允许写进程写
    V (mutex) ;  //释放互斥变量 count
  }
}

哲学家进餐问题
		○ 问题
			§ 五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在桌子上有五只碗和五只筷子，他们的生活方式是交替地进行思考和进餐。
			§ 平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐毕，放下筷子继续思考。
		○ 避免死锁
			§ 假如五位哲学家同时饥饿而都拿起的左边的筷子，当他们试图去拿右手边的筷子时，都将无筷子而陷入无限期的等待。
			§ 策略
				□ 至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐

semaphore chopstick[5]={1,1,1,1,1};
semaphore count=4; // 设置一个count，最多有四个哲学家可以进来
void philosopher(int i) {
	while(true) {
		think();
		wait(count); //请求进入房间进餐 当count为0时 不能允许哲学家再进来了
		wait(chopstick[i]); //请求左手边的筷子
		wait(chopstick[(i+1)%5]); //请求右手边的筷子
		eat();
		signal(chopstick[i]); //释放左手边的筷子
		signal(chopstick[(i+1)%5]); //释放右手边的筷子
		signal(count); //离开饭桌释放信号量
	}
}
				□ 仅当哲学家的左右两支筷子都可用时，才允许他拿起筷子进餐。可以利用AND 型信号量机制实现，也可以利用信号量的保护机制实现。利用信号量的保护机制实现的思想是通过记录型信号量mutex对取左侧和右侧筷子的操作进行保护，使之成为一个原子操作，这样可以防止死锁的出现

semaphore mutex = 1; // 这个过程需要判断两根筷子是否可用，并保护起来
semaphore chopstick[5]={1,1,1,1,1};
void philosopher(int i) {
	while(true) {
		/* 这个过程中可能只能由一个人在吃饭，效率低下，有五只筷子，其实是可以达到两个人同时吃饭 */
		think();
		wait(mutex); // 保护信号量
		wait(chopstick[(i+1)%5]); // 请求右手边的筷子
		wait(chopstick[i]); // 请求左手边的筷子
		signal(mutex); // 释放保护信号量
		eat();
		signal(chopstick[(i+1)%5]); // 释放右手边的筷子
		signal(chopstick[i]); // 释放左手边的筷子
	}
}

AND型信号量方式：

semaphore chopstick[5]={1,1,1,1,1};
do {
	//think()
	Swait(chopstick[(i+1)%5],chopstick[i]);
	//eat()
	Ssignal(chopstick[(i+1)%5],chopstick[i]);
} while(true)
				□ 规定奇数号的哲学家先拿起他左边的筷子，然后再去拿他右边的筷子；而偶数号的哲学家则先拿起他右边的筷子，然后再去拿他左边的筷子。按此规定，将是1、2号哲学家竞争1号筷子，3、4号哲学家竞争3号筷子。即五个哲学家都竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一个哲学家能获得两支筷子而进餐

semaphore chopstick[5]={1,1,1,1,1};
void philosopher(int i) {
	while(true) {
		think();
		if(i%2 == 0) {  //偶数哲学家，先右后左。
			wait (chopstick[(i + 1)%5]) ;
			wait (chopstick[i]) ;
			eat();
			signal (chopstick[(i + 1)%5]) ;
			signal (chopstick[i]) ;
		}
		else { //奇数哲学家，先左后右
			wait (chopstick[i]) ;
			wait (chopstick[(i + 1)%5]) ;
			eat();
			signal (chopstick[i]) ;
			signal (chopstick[(i + 1)%5]) ;
		}
	}
}
管程
	• 信号量机制编写程序困难，易出错。
	• 管程是一组过程，是对PV操作的封装,能更方便进行进程互斥、进程同步
		○ 各外部进程/线程仅通过管程提供的特定的入口才能访问共享数据
		○ 每次仅允许一个进程在管程内执行某个内部过程(各进程互斥访问管程,且互斥由编译器实现,不需要程序员操心)
	• 组成
		○ 共享数据结构，如生产者消费者问题的缓冲区
		○ 对数据结构初始化的语句
		○ 一组用来访问数据结构的过程
	• 过程即函数
死锁
	• 死锁
		○ 各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象
		○ 至少有2个或2个以上的进程发生死锁
		○ 发生死锁时必然处于阻塞态
	• 饥饿
		○ 由于长期得不到想要的资源，某进程无法向前推进的现象。
		○ 比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程饥饿。
		○ 饥饿可能是阻塞态(长期得不到需要的I/O设备)或者就绪态(长期得不到处理机)
	• 死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序故意设计的。
		○ 死锁与饥饿都是操作系统的问题，而死循环是程序的问题
死锁产生的必要条件
	• 必须同时满足以下4个条件
	• 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。
		○ 像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。
	• 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
	• 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。
	• 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。
	• 注意!发生死锁时一定有循环等待，但是发生循环等待时未必死锁
		○ 循环等待是死锁的必要不充分条件
		○ 如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了
什么时候会发生死锁
	• 对不可剥夺资源的不合理分配，可能导致死锁
		○ 对系统资源的竞争
			§ 各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。
		○ 进程推进顺序非法
			§ 请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、 P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1， 两者会因为申请的资源被对方占有而阻塞，从而发生死锁。
		○ 信号量的使用不当也会造成死锁
			§ 如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）
死锁的处理策略
	• 预防死锁。破坏死锁产生的四个必要条件中的一个或几个。
	• 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）
	• 死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。
预防死锁
	• 破坏互斥条件
		○ SPOOLing技术：把只能互斥使用的资源改造为允许共享使用（共享打印机）
		○ 缺点：为了系统安全，大部分系统资源仍需保持互斥性
	• 破坏不剥夺条件
		○ 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时 再重新申请。
		○ 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强 行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）
		○ 缺点
			§ 难以实现
			§ 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态 的资源，如CPU
			§ 反复地申请和释放资源会增加系统开销，降低系统吞吐量
			§ 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重 新申请。如果一直发生这样的情况，就会导致进程饥饿。
	• 破坏请求和保持条件
		○ 可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前， 不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。
		○ 缺点
			§ 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低
			§ 该策略也有可能导致某些进程饥饿。
	• 破坏循环等待条件
		○ 顺序资源分配法
			§ 首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源， 同类资源（即编号相同的资源）一次申请完。
		○ 原理分析
			§ 一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。
		○ 实例
			§ 进程PA，使用资源的顺序是R1, R2;
			§ 进程PB，使用资源的顺序是R2, R1;
			§ 若采用动态分配有可能形成环路条件,造成死锁;
			§ 若采用有序资源分配法:R1的编号为1,R2的编号为2：
			§ PA的申请次序则为：R1,R2
			§ PB的申请次序则为：R1,R2
			§ 这样就破坏了环路条件,避免了死锁的发生
		○ 缺点
			§ 不方便增加新的设备，因为可能需要重新分配所有的编号
			§ 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费
			§ 必须按规定次序申请资源，用户编程麻烦
避免死锁
银行家算法 - Dijkstra
	• 该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求
	• 这样申请者就可以很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，可避免死锁
	• 实例
		○ 假定系统中有10个资源，分配情况如下：
			§ 进程P，已占用资源2个，还需申请资源4个
			§ 进程Q，已占用资源4个，还需申请资源2个
			§ 进程R，已占用资源2个，还需申请资源6个
		○ 此时，系统中只剩下2个资源，这时就要考察能满足哪个进程
		○ 它不能满足P和R的最大要求，能满足Q，于是将剩下的2个资源分配给Q，Q就能完成，再释放所占用的6个资源
		○ 这6个资源，又能分配给P或者R，不管分配给谁，都能保证完成
安全序列
	• 如果系统按照这种序列分配资源，则每个进程都能顺利完成。
	• 只要能找出一个安全序列，系统就是安全状态
	• 安全序列可能有多个
