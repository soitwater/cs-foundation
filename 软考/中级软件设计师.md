# 软件设计师

- 通过率20% - 30%
- 来自日本
- 上午下午考试时间150分钟, 选择题 + 问答题

## 计算机组成与体系结构
### 数据的表示
- R进制转换为十进制的方法都是`按权展开法`, 具体操作方式为：
  * 将R进制的每一位数值用R^k形式表示, 即幂的底数是R, 指数为k, 
  * k与该位和小数点之间的距离有关
    - 当该位位于小数点左边, k值是该位和小数点之间数码的个数
    - 当该位位于小数点右边, k值是负值, 其绝对值是该位和小数点之间数码的个数加1
- 十进制转换为二进制的方法
  ```js
  // 如: 11 转换为 1011
  11 除以 2, 商 5, 余数 1    // 这里的 商5 将作为下一次的被除数
   5 除以 2, 商 2, 余数 1
   2 除以 2, 商 1, 余数 0
  // 将所有的`余数`逆序排列, 最前面加上最后一个`商数`, 即为答案, 如上述的 `1-0-1-1`
  ```
- 将二进制快速转换为八进制或十六进制
  * 从右到左, 每3个二进制位对应一个8进制位
  * 从右到左, 每4个二进制位对应一个16进制位
  * 例如
    ```js
      二进制 = ' 10 001 110'
      八进制 = '  2   1   6'
      二进制 = ' 1000 1110'
    十六进制 = '    8    E'
    ```
- 原码
  * 把一个数转换成二进制
  * 最左边的那一位是符号位, 0 表示 正数, 1 表示 负数
  * 一般是8位数字
- 反码: (`方便原码和补码的相互转换`)
  * 正数的`原码`与`反码`与`补码`是一样的
  * 负数除了`符号位`,其他位上的数字全部取反
- 补码: (`将加减运算统一为加法运算`)
  * 正数的`原码`与`反码`与`补码`是一样的
  * 负数的`补码`是在其`反码`的基础上加`1`
- 移码: (`用作浮点数的阶码`)
  * 将`正数`与`负数`的最高位(符号位)取反
- 数值的表示范围
  ```js
  // 限整数
  // 一个字节, 8个位, 下面的 n 表示 8
  原码：-(2^(n - 1) - 1) ~ 2^(n - 1) - 1
  反码：-(2^(n - 1) - 1) ~ 2^(n - 1) - 1
  补码：-2^(n - 1) ~ 2^(n - 1) - 1
  // 
  ```
- 浮点数运算
  * 浮点数表示：即数学中的科学计数法, `1000`的浮点数是`1.0 x 10^3`
  * 浮点数的加法
    ```js
    // 例如: 1.0 * 10^3 + 1.19 * 10^2
    // 第一步：对阶, 将 1.19 * 10^2 变为 0.119 * 10^3
    1.0 * 10^3 + 0.119 * 10^3
    // 第二步：尾数计算, 1.119*10^3 与 1.0*10^3 与 0.119*10^3 中的 1.0、 0.119、1.119 称为尾数
    1.0 + 0.119 = 1.119
    // 第三步：结果格式化
    尾数的整数部分是`几点几`, 且十进制的尾数的整数部分最大不能超多9
    ```
### 计算机结构
- 结构包括
  ```js
  - 主机
    * 主存储器(内存)
    - CPU
      * 运算器
        - 算术逻辑单元 ALU
        - 累加寄存器 AC
        - 数据缓冲寄存器 DR
        - 状态条件寄存器 PSW
      * 控制器
        - 程序计数器 PC
        - 指令寄存器 IR
        - 程序译码器
        - 时序部件
  ```
- Flynn分类法
  * Flynn根据不同的指令流和数据流组织方式，把计算机系统分成如下4类
  * 单指令流单数据流（SISD）
    - 结构：控制部分 一个; 处理器：一个; 主存部分：一个
    - 特性：
    - 代表：单核处理器系统、386、486、大多数单片机
  * 单指令流多数据流（SIMD）
    - 结构：控制部分 一个; 处理器：多个; 主存部分：多个
    - 特性：各处理器以异步的形式执行同一条指令
    - 代表：并行处理器、`阵列处理器`(典型, 用于处理数组)、超级向量处理器
  * 多指令流单数据流（MISD）
    - 结构：控制部分 多个; 处理器：一个; 主存部分：多个
    - 特性：被证明是不可能, 至少是不实际的
    - 代表：目前不存在, 有文献称流水线计算机为此类
  * 多指令流多数据流（MIMD）
    - 结构：控制部分 多个; 处理器：多个; 主存部分：多个
    - 特性：能够实现作业、任务、指令等各级全面并行
    - 代表：多处理机系统、多计算机
- CISC与RISC
  * CISC
    - Complex Instruction Set Computers, 复杂指令集计算集
    - 指令：数量多, 使用频率差别大, 可变长格式
    - 寻址方式：支持多种
    - 实现方式：微程序控制技术（微码）
    - 其他：研制周期长
  * RISC
    - Reduced Instruction Set Computers, 精简指令集计算集
    - 指令：数量少, 使用频率差别小, 定长格式, 大部分为单周期指令，操作寄存器，只有`Load / Store`操作内存 
    - 寻址方式：支持方式少
    - 实现方式：增加了通用寄存器; 硬布线逻辑控制为主; 适合采用流水线;
    - 其他：优化编译, 有效支持高级语言
- 流水线
  * 考察流水线的计算问题
  * 概念
    ```js
    // 未使用流水线执行指令情况
    —— 取址 ——————— 取址 ————————— 取址
    ——————— 分析 ——————— 分析 ———————— 分析
    —————————— 执行 ————————— 执行 ———————— 执行
    // 使用流水线执行指令情况
    —— 取址-分析-执行
    ———— 取址-分析-执行
    —————— 取址-分析-执行
    ```
  * 例题
    ```js
    // 若指令流水线把一条指令分为取值、分析和执行三部分,且三部分的时间分别是t取值=2ns,t分析=2ns,t执行=1ns。
    // 则流水线周期是多少? 100条指令全部执行完毕需()ns?
    
    流水线周期 = 执行时间最长的一段 = 2纳秒、2纳秒、1纳秒, 这里面最长的是 2纳秒, 故流水线周期是 2纳秒;
    // 优先使用理论情况的公式
    (理论)流水线的计算公式为 = 1条指令执行的时间 + (指令条数 - 1) * 流水线周期 = (2 + 2 + 1) + (100 - 1) * 2 = 203 纳秒
    (实际)流水线的计算公式为 = (一条指令被分成几个部分 + 指令条数 - 1) * 流水线周期 = (3 + 100 - 1) * 2 =  204 纳秒
    该流水线的吞吐率 = 100 / 203
    ```
- 流水线的吞吐率(`单位时间内流水线所完成的任务数量或输出的结果数量`)
  * 公式：
    - 吞吐率 = 指令条数 / 流水线执行时间
    - 最大吞吐率 = 1 / 流水线周期
- 流水线的加速比计算(`完成同样的一批任务, 不使用流水线所用的时间与使用流水线所用的时间之比, 称为流水线的加速比`)
  * 不使用流水线所用的时间
    - 以上述例题为背景, 不使用流水线所用的时间 = (2 + 2 + 1) * 100 = 500
  * 加速比越大越好
- 流水线的效率
  * 例题
    ```js
    // 若指令流水线把一条指令分为4部分,各部分消耗的时间分别是：1纳秒、1纳秒、1纳秒、3纳秒, 执行4条该指令, 则其流水线效率为?
    // 方案：画时空图, 图中的数字表示真正工作的时间, 数字相同表示同一条指令
    流水线效率 = 有数字的格子的面积 / 全部格子的面积 = (1ns + 1ns + 1ns + 3ns) * 4 / 15 * 4 = 2 / 5
    ```
  * ![软件设计师1_流水线效率.png](../assets/软件设计师1_流水线效率.png)
- 层次化存储结构
  * 速度由快到慢
    - `寄存器`(位于CPU)
    - `Cache`(不是必须的, 因为CPU可以直接与内存交换数据; 但没有Cache, 交换速度极慢)
    - `内存`(主存)
    - `外存`(辐存)：硬盘、光盘、U盘
- Cache
  * 功能
    - 提高CPU数据输入输出的速率,突破冯诺伊曼瓶颈(即CPU与存储系统间数据传送带宽限制)
    - 在计算机存储体系中, Cache是访问速度最快的层次(选项中有`寄存器`的时候,选择`寄存器`)
    - Cache改善系统性能依据的是程序的局部性原理
  * 公式
    - 如果以`h`代表对Cache的访问命中率，`t1`代表Cache的周期时间，`t2`代表主存储器周期的时间，以读操作,使用'Cache＋主存储器'的系统的平均周期为`t3`，则
      * t3 = h * t1 + (1 - h) * t2
    - 其中：`1 - h`又称为失效率
- 局部性原理
  * 概念：相当于程序运行到一个函数体内时,此时访问的变量都是局部作用域里的变量,这些局部变量会被频繁访问
  * 时间局部性：被引用过一次的存储器位置在未来会被多次引用 (将经常被访问的变量声明为全局变量,让所有函数都能访问)(通常是在循环体中)  
  * 空间局部性：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用 (操作数组时, 程序先访问其中一个元素, 又立即访问该元素相邻的元素) 
  * 工作集理论：工作集是进程运行时被频繁访问的页面的集合
- 主存 - 分类
  * 随机存取存储器 `RAM` (断电后存储的信息就丢失)
    - DRAM (Dynamic RAM, 动态RAM) SDRAM
    - SRAM (Static RAM, 静态RAM)
  * 只读存储器 `ROM`
    - MROM
    - PROM
    - EPROM
    - 闪存存储器(flash memory, 闪存)
- 主存 - 编址
  * 概念
    - 内存编址：存储器由一块块存储单元组成，对每一存储单元进行标识，即为内存编址
    - 存储器由若干个芯片组成
    - `存储器大小 = 芯片个数 x 每个芯片的容量`
    - `每个芯片的容量 = 一个地址代表的容量 x 编址总数`
    - 数据总线：
      * 计算机一次处理`n位`的数据,其数据总线的长度为`n`;
      * 数据总线的长度，并不一定代表一个地址的长度
      * 数据总线`宽度`有`z位`，一个`字`就由`z位`组成，如`64位`计算机，一次可以处理`64位`数据
    - 地址总线
      * 需要`x位`二进制数来表示所有的地址, 则地址总数的个数为`x`;
  * 题目
    - 一
      ```js
      // 假如某个存储器只有一个芯片（8*4bit），该芯片的容量为32bit（位）；
      // 计算机每次处理4bit（位）数据；
      // 内存按4bit（位）来编址，那个该芯片有多少个地址，数据总线的长度和地址总线的个数分别是多少？
      - 题目中的`内存按4bit（位）来编址`表示`一个地址代表的容量`;若没有提及,则按`8bit`;
      - 内存容量 = 一个地址代表的容量 * 地址的个数
      - 故,地址的个数 = 32 / 4 = 8个
      - `计算机每次处理4bit（位）数据`, 表示数据总线的长度是`4`
      - 求`地址总数的个数`，需先求`地址的个数`(8个), 看`8`是`几个二进制`表示的, 答案就是`几`
      ```
      * ![内存编址_概念题1](../assets/内存编址_概念题1.png)
      * ![内存编址_概念题1](../assets/内存编址_概念题2.png)
    - 二
      ```js
      // 内存按字节编址，地址从 A4000H 到 CBFFFH ，共有多少个字节?
      CBFFF - A4000 + 1 = 28000 (十六进制)
      28000 (十六进制) 转化为 十进制 = 2 * 16^4 + 8 * 16^3 = 163840 个
      163840 个 / 1024 = 160k 个地址
      // 若用存储容量为32k x 8bit 的存储芯片构成该内存, 至少需要几片?
      因为内存按字节编址, 故总存储 160k * 8bit
      32k x 8bit 表示单片芯片容量, (160k * 8bit)/ (32k * 8bit) = 5(片)
      ```
- 磁盘结构与参数
  * 磁头，磁道(存数据的圆环)，扇区（磁道的某一段）
  * 磁盘存取时间 = 寻道时间 + 等待时间 (即：平均定位时间 + 转动延迟)
    - 寻道时间：磁头移动到磁道所需的时间
    - 等待时间：等待读写的扇区转到磁头下方所用的时间
  * 题目
    - ![磁盘计算题1](../assets/磁盘计算题1.png)
    - ![磁盘计算题答案](../assets/磁盘计算题_1.png)
    - ![磁盘计算题答案](../assets/磁盘计算题_2.png)
    - ![磁盘计算题答案](../assets/磁盘计算题_3.png)
    - 磁盘一旦开始工作,就不会停止,会一直匀速转动
    - 题解中的最后一个特殊，其实应该理解称第一个是特殊的，磁头一开始就在`R0`,`R0`只需要`3 + 3`ms
- 总线
  * 分类(根据所处位置不同)
    - 内部总线
    - 系统总线
      * 数据总线：
      * 地址总线：
      * 控制总线：
    - 外部总线
- 系统可靠性分析(串联系统与并联系统)
  * 常考计算题
  * 串联：R1与R2与R3与R4串联，则其可靠性为(一直相乘)：`R = R1 * R2 * R3 * R4`
    - 因为串联中任何一个损坏，都会导致整体故障
  * 并联：R1与R2与R3并联，则可靠性 = `1 - (1 - R1) * (1 - R2) * (1 - R3)`
    - 并联部分有一个能正常运行，则系统能正常运行
  * n模冗余系统与混合系统（少考）
    - R1、R2、Rm都执行统一任务, 各自给出自己的输出接口; 表决器根据所有结果，表决哪一结果最可靠(如: 少数服从多数)
    - ![](../assets/模冗余系统与混合系统1.png)
- 差错控制：CRC与海明校验码
  * 码距：
    - 一个编码系统的码距是整个编码系统中任意(所有)2个码字的最小距离
    - 若用1位长度的二进制编码。若A=1，B=0。这样A,B之间的最小码距为1(`无法检错`)    
    - 若用2位长度的二进制编码。若A=11，B=00。这样A,B之间的最小码距为2(`若`发送了`10`过来,则发现了错误,无法检错)    
    - 若用3位长度的二进制编码。若A=111，B=000。这样A,B之间的最小码距为3  
    - 一个码组内为了`检测`e个误码，要求最小码距d应满足：`d > e + 1`
    - 一个码组内为了`纠正`t个误码，要求最小码距d应满足：`d > 2t + 1`
- 循环校验码CRC
  * 可以检错，不能纠错
  * 二进制左移一位：`01100`左移一位为`11000`
  * 模2加减法：（异或）（相同为0，不同为1）
    ```js
    0 ± 0 = 0
    1 ± 1 = 0
    0 ± 1 = 1
    1 ± 0 = 1

      1 1 0 1
    ± 1 0 0 1
    ---------
      0 1 0 0
    ```
  * 普通的二进制除法(长除法)
    - 类似于十进制的长除法((172 / 4) === 43)
    - 从被除数的首位开始, 当被除数 > 除数, 商对应的位置上写`1`,再做二进制加减法
      * ![二进制加减法](../assets/二进制加减法.png)
  * 模2除法：是指在做除法运算的过程中不计其进位的除法（不向上一位借位）
    - 步骤：
      ```js
      // 假设被除数X，除数P，余数R，
      // 1. X对P做 模2加减法，此时商对应的位置为1
      // 2. 所得余数R，不断左移，直至首位不是0，继续重复步骤1

      // 求 1111000 对 1101 的模2除法（答案 商1011，余数111）
      // 求 10111 对 110 的模2除法 （答案 商110，余数11）
      ```
  * 原始报文为`11001010101`,其生成多项式为`x^4 + x^3 + x + 1`,对其进行CRC编码后的结果为?
    ```js
    多项式为`x^4 + x^3 + x + 1` 暗示2^4、2^3、2^1、2^0位置有1，即`11011`
    再在原始报文 11001010101 的末尾添加 n 个 0，其中0的个数即为`多项式的长度 - 1`, 得到 110010101010000
    用 110010101010000 对 11011 做模2除法，得到一个余数 0011 ，余数替换被除数的末尾4位
    答案 110010101010011
    (110010101010011 对 11011 做模2除法，若其余数为0，则表示传输正确)
    ```
  * [参考1](https://zh.wikihow.com/%E5%81%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97)
  * [参考2](https://blog.csdn.net/qq_33411687/article/details/82593466)
- 海明校验码
  * 分为`校验位`和`信息位`
    - 校验位：位于`2^n`位，如`2^0`、`2^1`、`2^2`、`2^3`、`2^4`、`2^5`......
    - 信息位：校验位之间的空位，填充信息位;信息位放的是原信息
    - 若`2^r 刚好 >= k + r + 1`, (k 是信息位个数, r是校验位个数); 再`k + r`，即为海明码的长度
    - 校验位填入什么值?
      ```js
      1011 的海明码 1010101
      // 求校验码对应的值
      位置 3 为信息位，3 的二进制为 011，看`1`的位置，说明它影响了
      位置 5 为信息位，5 的二进制为 101
      位置 6 为信息位，6 的二进制为 110
      位置 7 为信息位，7 的二进制为 111
      
      位置 1 为校验位，1 的二进制为 001，
      对所有信息位上值的二进制的`2^0`位上的值做异或操作，
      得到：1 异或 1 异或 0 异或 1 = 1，
      位置 1 的值为 1

      同理位置2，1 异或 0 异或 1 异或 1 = 0，
      同理位置4，0 异或 1 异或 1 异或 1 = 0，
      // 注意：`异或`需要按照顺序，从低位开始到高位
      最终的海明码：1010101
      ```
      * ![海明码1](../assets/海明码1.png)
  * 海明码纠错
  
  
