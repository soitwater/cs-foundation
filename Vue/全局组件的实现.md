# 全局组件的实现

## 方法一：外部UI库的开发
略

## 方法二：Vue.use()
一般的UI库都会使用这种方法来进行按需引入    
- 在src/components/message/message.vue
```js
<template>
  <div class="message" :class="type" v-show="show">
    <span class="text">{{text}}</span>
  </div>
</template>

<script type="text/ecmascript-6">
  export default {
    name: 'message',
    props: {
      type: {
        type: String,
        default: 'info',
        validator: val => ['success', 'error'].includes(val)
      },
      text: {
        type: String,
        default: ''
      },
      show: {
        type: Boolean,
        default: false
      }
    }
  }
</script>

<style scoped>
  .message {
    position: fixed;
    top: 40px;
    text-align: center;
    left: 50%;
    transform: translateX(-50%);
    min-width: 400px;
    background: #f5f5f5;
    border-radius: 4px;
    z-index: 1000;
  }
  .message.error {
    color: red;
  }
  .message.success {
    color: greenyellow;
  }
</style>
```
- 在`src/components/message/index.js`
```js
import Message from './Message.vue'

const MESSAGE = {
  duration: 3000, // 显示的时间 ms
  animateTime: 300, // 动画时间,表示这个组件切换show的动画时间
  install(Vue) {
    if (typeof window !== 'undefined' && window.Vue) {
      Vue = window.Vue
    }
    Vue.component('Message', Message) // 全局注册组件

    function msg(type, text, callBack) {
      let msg
      let duration = MESSAGE.duration
      if (typeof text === 'string') {
        msg = text
      } else if (text instanceof Object) {
        msg = text.text || ''
        if (text.duration) {
          duration = text.duration
        }
      }
      let VueMessage = Vue.extend({
        render(h) { // 不用 template 选项是为了避免多引入一个 vue-template 编译代码,避免增大依赖库体积
          let props = {
            type,
            text: msg,
            show: this.show
          }
          return h('message', { props })
        },
        data() {
          return {
            show: false
          }
        }
      })
      let newMessage = new VueMessage()
      let vm = newMessage.$mount()
      let el = vm.$el
      document.body.appendChild(el) // 把生成的提示的dom插入body中
      vm.show = true
      let t1 = setTimeout(() => {
        clearTimeout(t1)
        vm.show = false  //隐藏提示组件，此时会有300ms的动画效果，等动画效果过了再从body中移除dom
        let t2 = setTimeout(() => {
          clearTimeout(t2)
          document.body.removeChild(el) //从body中移除dom
          newMessage.$destroy()
          vm = null // 设置为null，好让js垃圾回收算法回收，释放内存

          callBack && (typeof callBack === 'function') && callBack()
        }, MESSAGE.animateTime)
      }, duration)
    }

    Vue.prototype.$message = { // 将组件 message 挂载到vue原型上，暴露其中的方法
      success(text, callBack) {
        if (!text) return
        msg('success', text, callBack)
      },
      error(text, callBack) {
        if (!text) return
        msg('error', text, callBack)
      },
    }
  }
}
export default MESSAGE
```
- 在main.js
```js
import vMessage from '@/components/message/index.js'
Vue.use(vMessage)
```
- 使用,在其他的组件内部直接使用
```js
this.$message.success('普通消息')
```

## 方法三：Vue.component()
Vue.component() 与 Vue.use()的区别在于:后者需要提供一个install方法,在install方法里其实调用的还是Vue.component()  


## 参考
- [用Vue.extend()来做一个全局提示组件](https://www.jianshu.com/p/b931abe383e3)
