# 冷知识

- Vue里给v-html元素添加样式  
  在选泽器前添加`>>>`, [参考](https://blog.csdn.net/weixin_42412046/article/details/80804285)
- 使用`CDN`加载`Vue.js`  
  * [参考1](https://www.jianshu.com/p/5d061efd036e)
  * [vue对不同构建版本的解释](https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A)
- img的src链接
  * 在`src/assets`文件夹下添加图片
  * 在vue文件中写：  
    - 需要用到`require`(为什么Vue里面如果用代码控制img，src必须用require(路径)，而不能直接src=路径？)  
      * vue 的项目一般走 Webpack 编译,Webpack在解析`template`时,遇到img标签时,如果src是静态字符串且不是以`http`等开头,那么webpack会认为是相对源码目录的图片
      * 假如`<img>`使用了变量，那么webpack在打包时是不知道该变量的值的,所以需要使用`require()`??
    ```html
    <img
      :src="require('../../../assets/logo.png')"
      :alt="logo"
    />
    ```
- 操纵Vue实例的原型链：为所有的Vue实例添加共有变量  
  例如：
  ```js
  // 在main.js
  import Vue from 'vue'
  import axios from 'axios'
  Vue.prototype.$axios = axios

  // 在其他Vue单文件,不必引入 import axios from 'axios' ,即可使用 axios
  this.$axios.get()
  ```
- `<navigator @getSaleInfoList2selltable="listData = $event" />`这里的$event相当于下面的`param`:
   ```js
   this.$emit("getSaleInfoList2selltable", param)
   ```
- 在vue-cli3的项目里,在CMD中键入命令`vue inspect > output.js`,在项目的根路径下将生成`output.js`,里面是vue的默认webpack配置
- `vue.config.js`里的链式写法参考了[网站](https://github.com/neutrinojs/webpack-chain),直接网页全局搜索相应的关键字,可以模仿对应的写法
- 放在`public`文件夹的资源只会简单的复制,放在`asserts`文件夹里的资源会被打包处理  
  [官方文档](https://cli.vuejs.org/zh/guide/html-and-static-assets.html#public-%E6%96%87%E4%BB%B6%E5%A4%B9)
- 在vue中,`this.$root.$on('xxx', data)`不会自动关闭,所以在每次`this.$root.$on`之前,最好执行  
  ```js
  this.$root.$off('xxx')
  this.$root.$on('xxx', data)
  ```
- 在vue单文件里`window.sysysy = this`,那么就可以在控制台上通过`window.sysysy`调试这个`vue`文件
- `.sync`运算符  
  * [参考](https://www.cnblogs.com/foreveronlymiss/p/foreveronlymiss.html)
  * 用于`prop`中,当子组件的数据修改时,将导致父组件的数据也修改(违背了单项数据流的初衷,故后来`.sync`成了一个语法糖),其实际作用如下：
  * `<child  :foo.sync='msg'></child>`  就会被扩展为：    
    `<child  :foo='bar'  @update:foo='val => bar = val'>`     
    当子组件需要更新 foo 的值的时候，他需要显示的触发一个更新事件: `this.$emit('update:foo', newValue)`  
- active-class 是哪个组件的属性？
  * `<router-link>`
  * `exact-active-class`或者`active-class`默认值是`router-link-active`
  * router-link 默认情况下的路由是模糊匹配，例如当前路径是 /article/1 那么也会激活 `<router-link to="/article">`
  * 当设置 exact-active-class 以后，这个 router-link 只有在当前路由被全包含匹配时才会被激活 exact-active-class 中的class。
  * 例如
    - `<router-link to="/article" active-class="router-active"></router-link>`  
      当用户访问 /article/1 时会被激活为`<a href="#/article" class="router-active"></a>`
    - 而当使用`<router-link to="/article" exact-active-class="router-active"></router-link>`  
      当用户访问 /article/1 时，不会激活这个link的class`<a href="#/article"></a>`  
- `keep-alive`原理
  * 使用
    ```js
    // 在 router.js
     meta:{keepAlive: false}
    // 使用 v-if 或者 路由守卫判断是否需要 缓存
     <keep-alive>
      <router-view v-if="$route.meta.keepAlive"></router-view>
    </keep-alive>
    <router-view v-if="!$route.meta.keepAlive"></router-view> 
    ```
  * 其实就是在组件created时将需要缓存的VNode节点保存在this.cache中  
    在render时,如果VNode的name符合在缓存条件（可以用include以及exclude控制），则会从this.cache中取出之前缓存的VNode实例进行渲染。
- 指令  
  以`v-time`将时间戳转换为相对本机时间的多久之前,为例子
  ```js
  // 一. 写一个Time的库								
  let Time = {								
    getUnix () { // 获取当前时间戳								
      let date = new Date()								
      return date.getTime()								
    },								
    getTodayUnix () { // 获取今天0点0分0秒的时间戳								
      let date = new Date()								
      date.setHours(0)								
      date.setMinutes(0)								
      date.setSeconds(0)								
      date.setMilliseconds(0)								
      return date.getTime()								
    },								
    getYearUnix () { // 获取今年1月1日0点0分0秒的时间戳								
      let date = new Date()								
      date.setMonth(0)								
      date.setDate(1)								
      date.setHours(0)								
      date.setMinutes(0)								
      date.setSeconds(0)								
      date.setMilliseconds(0)								
      return date.getTime()								
    },								
    getLastDate (time) { // 获取标准年月日								
      let date = new Date(time)								
      let month = date.getMonth() + 1 < 10 ? "0" + (date.getMonth() + 1) : date.getMonth() + 1								
      let day = date.getDate() < 10 ? "0" + date.getDate() : date.getDate()								
      return date.getFullYear() + "-" + month + "-" + day								
    },								
    getFormatTime (timestamp) { // 转换时间								
      let now = this.getUnix() // 当前时间戳								
      let today = this.getTodayUnix() // 今天0点时间戳								
      let year = this.getYearUnix() // 今年0点时间戳								
      let timer = (now - timestamp) / 1000 // 转换为秒级时间戳								
      let tip = ""								
      if (timer <= 0) {								
        tip = "刚刚"								
      } else if (Math.floor(timer / 60) <= 0) {								
        tip = "刚刚"								
      } else if (timer < 3600) {								
        tip = Math.floor(timer / 60) + "分钟前"								
      } else if (timer >= 3600 && (timestamp - today >= 0)) {								
        tip = Math.floor(timer / 3600) + "小时前"								
      } else if (timer / 86400 <= 31) {								
        tip = Math.ceil(timer / 86400) + "天前"								
      } else {								
          tip = this.getLastDate(timestamp)								
      }								
      return tip								
    },								
  }								
  								
  export {Time}								
  ```
  ```js
  // 二. 自定义指令					
  directives: {					
    "time": {					
      bind (el, binding) {					
        el.innerHTML = Time.getFormatTime(binding.value)					
        el.__timeout__ = setInterval(() => {					
          el.innerHTML = Time.getFormatTime(binding.value)  					
        }, 60000)					
      },					
      unbind () {					
        clearInterval(el.__timeout__)					
        delete el.__timeout__					
      }					
    }					
  },					
  ```
  ```js
  // 三. 使用自定义指令								
  v-time="timeNow"								
  v-time="timeBefore								
  timeNow: (new Date()).getTime(),								
  timeBefore: 1554988307968,								
  ```
- `e.target`
  ```js
  Vue获取当前点击元素的兄弟元素，父元素，子元素							
  获取dom元素 https://www.cnblogs.com/meng1314-shuai/p/7455575.html							
  以及 https://blog.csdn.net/qq_15256443/article/details/82584931							
  在<template/>中，<button @click = “getEvent($event)”>点击</button>		

  // e.target 是你当前点击的元素							
  // e.currentTarget 是你绑定事件的元素							
  # 获得点击元素的前一个元素							
  e.currentTarget.previousElementSibling.innerHTML							
  # 获得点击元素的第一个子元素							
  e.currentTarget.firstElementChild							
  # 获得点击元素的下一个元素							
  e.currentTarget.nextElementSibling							
  # 获得点击元素中id为string的元素							
  e.currentTarget.getElementById("string")							
  # 获得点击元素的string属性							
  e.currentTarget.getAttributeNode('string')							
  # 获得点击元素的父级元素							
  e.currentTarget.parentElement							
  # 获得点击元素的前一个元素的第一个子元素的HTML值							
  e.currentTarget.previousElementSibling.firstElementChild.innerHTML			
  ```