# 数据库基础

## 基础
- 表：由行与列组成，行：记录，列：字段
- 视图：表的查询结果即为视图
- 主键：可以唯一标识当前行的字段（其值不可为NULL），应保证每一个表都有一个主键
- 外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系

## 检索数据
- SELECT 列名 FROM 表名;
- SELECT 列名1, 列名2, 列名3, … , 列名n  From 表名;
- SELECT * FROM 表名;   `检索所有列， * 表示通配符`
- SELECT DISTINCT 列名 FROM 表名; `列下相同元素只显示一次`
  * 注意 DISTINCT 是应用于全部列的如: `SELECT DISTINCT 列名1, 列名2 FROM 表名;`
- SELECT 列名 FROM 表名 LIMIT 5; `限制返回结果不多于5`
- SELECT 列名 FROM 表名 LIMIT 4,5; `返回从行4开始的5行`
  * 上述等价于`SELECT 列名 FROM 表名 LIMIT 5 OFFSET 4;`
- 使用完全限定的表名、列名
  * `SELECT 表名.列名 FROM 库名.表名;`

## 排序数据
- 未经限定排序顺序的数据，它在检索之后的顺序不一定是入表时的顺序(可能受到在操作数据时MySQL重用回收存储空间的影响)，因此未经限定的数据顺序无意义。
- 根据列名1(或列名2)排列列名1下数据的顺序
  * `SELECT 列名1 FROM 表名 ORDER BY 列名1(或列名2);`
- 按多个列排序(先按列名1排序,列名1同序情况下才按列名2排序)
  * `SELECT 列名1,列名2,列名3 FROM 表名 ORDER BY 列名1,列名2;`
- 降序排序
  * SELECT 列名1 FROM 表名 ORDER BY 列名1 DESC;
  * SELECT 列名1,列名2 FROM 表名 ORDER BY 列名1 DESC, 列名2 DESC;
  * DESC 只影响它前一个列名
  * ASC  是升序的关键字，但系统默认升序，故它没什么意义
- 找出最值
  * SELECT 列名 FROM 表名 ORDER BY 列名1 DESC LIMIT 1;
  * 注意 LIMIT 在 ORDER BY 之后，ORDER BY 在 FROM 之后
  * ORDER BY 字段1 DESC `/* 排序; 字段1可不在 SELECT 中,  desc 表示 降序 */ `
  * ORDER BY 字段1 DESC, 字段2 `/* 先按字段1降序排列, 当字段1相同时, 则按字段2升序排列 */` `/* ORDER BY 放在 WHERE 之后 */`
  * TOP 5 `/* 最上的5行 */`
  * IN `/* 常与子查询配合使用 */`
  * LIKE

## 过滤数据
- SELECT 姓名 FROM 班级花名册 WHERE 姓名 = 李明;
  * WHERE 放在FROM之后，放在ORDER BY之前
  * SELECT number FROM 班级花名册 WHERE number BETWEEN 5 AND 10;

## 空值检查
- NULL 空值(`空值不是 0、空字符串或仅仅包含空格`)
  * SELECT name FROM 花名册 WHERE number IS NULL; `(IS NULL 检查空值)`
  * NULL具有特殊含义，语句并不会返回name中number = NULL的结果(`<>`是不等于) `SELECT name FROM 花名册 WHERE number <> 01;`
- 多条件检查数据
  * SELECT name, price FROM 价格表 WHERE name = '大米' AND price = 50;
  * SELECT name, price FROM 价格表 WHERE name = '大米' OR price = 50;
- AND 与 OR 的复合使用
  * 如: 列出价格为10元(含)以上且id为02或03的所有产品
    - SELECT name, price FROM 价格表 WHERE (id = 02 OR id = 03) AND price >= 10;
    - AND 的优先级比 OR 更高
- IN关键字
  * SELECT name FROM 价格表 WHERE id IN (1002,1003); `等价于：` SELECT name FROM 价格表 WHERE id = 1002 OR id = 1003;
  * 注意IN之后必须有圆括号
- NOT关键字
  * SELECT name, price FROM 价格表 WHERE id NOT IN (1002,1003);


## 使用通配符进行过滤
- 如：搜索名字中带”树”的人
  * LIKE关键字,如：`SELECT id FROM 价格表 WHERE name LIKE 'jet%'('%jet%')('%jet');`
  * 上述语句搜索以jet开头(包含jet)(以jet为末尾)的字符串
  * 注意 % 表示0个，1个或多个字符
- _ 关键字与 % 关键字类似,但 _ 表示一个字符

## 用正则表达式进行搜索
- 列出name中包含1000的结果
  * SELECT name FROM 价格表 WHERE name REGEXP '1000';
- `SELECT name FROM 价格表 WHERE name REGEXP '.1000';` 等价于 `SELECT name FROM 价格表 WHERE name LIKE '_1000';`
- `.` 的功能相当于 `_`
- 正则表达式的搜索一般不区分大小写，
  * 为区分大小写，使用BINARY，如：WHERE name REGEXP BINARY 'JetPack .000';
- 匹配范围
  * [0123456789] 等价于 [0-9]
  * [123] 等价于 [1-3]
  * 从a到z 等价于 [a-z]
- 匹配特殊字符
  * 如为了匹配 `.  []  ^  $` 等，应使用 `\\` 为前导
  * `\\-`  表示查找 `-`
  * `\\.`  表示查找 `.`
  * 注: 之所以使用两个 `\\` 是因为MySQL使用 `\\` 来解释 `\`
- 其他匹配
  * 像正则里的`*  +  ?  {n}  {n,}  {n,m}`表示数量的元字符在MySQL中同样适用
    - 如：`SELECT name FROM 价格表 WHERE name REGEXP 'sticks?'`
    - s后的 ? 使 s 可选，因为 ? 匹配它前面的任何字符的0次或1次出现
    - 结果是列出包含stick或包含sticks

## `|` 关键字(效果等同于 OR)
- 搜索name为1000或2000或3000的结果
  * SELECT name FROM 价格表 WHERE name REGEXP '1000|2000|3000';

## `[ ]` 关键字:另一种形式的OR语句
- `SELECT name FROM 价格表 WHERE name REGEXP '[123] Ton';`
  * 等价于：`SELECT name FROM 价格表 WHERE name REGEXP '1 Ton|2 Ton|3 Ton';`
  * 等价于：`SELECT name FROM 价格表 WHERE name REGEXP '[1|2|3] Ton';`

## 关系运算符
|类型|符号|
|-|-|
|关系运算符|`   >  <  !=  =  >=   <>`|
|逻辑运算符|`   NOT  AND  OR  `|
|特殊条件运算符|`IN,  NOT IN,  BETWEEN ... AND ... (闭区间),  NOT BETWEEN,  LIKE,  NOT LIKE,  IS NULL,  IS NOT NULL`|

## 函数
### 大多数SQL支持一下类型的函数：
- 文本函数：用于处理文本串(删除、填充值、转换值为大写或小写)
  * Upper()：返回串的大写
  * 如：`SELECT name, Upper(name) AS name_upcase FROM 花名册 ORDER BY name;`
- 数值函数：用于在数值数据上进行算术操作(返回绝对值、进行代数运算)
- 系统函数：返回DBMS正使用的特殊信息（返回用户登录信息，检查版本细节）
- 日期和时间函数：处理日期和时间值并从这些值中提取特定成分（返回两个日期之差，检查日期有效性等）

## 聚集(合)函数
- 不检索所有数据情况下获得汇总数据(和、平均数……)
- 如：`AVG()  COUNT()  MAX()  MIN()  SUM()`
- 举例
  * `SELECT AVG(price) AS avg_price FROM 价格表;` AVG()还可以通过WHERE语句来确定特定列或行的平均值;
  * `SELECT COUNT(*) AS num FROM 价格表;` COUNT(*)对表中行的数目进行计数(包括值为NULL的行)
  * `SELECT COUNT(email) AS num FROM 价格表;` COUNT(column)对表中行的数目进行计数(不包括值为NULL的行)
  * `SELECT MAX(price) AS max_price FROM 价格表;` MAX()返回指定列中的最大值, MAX()括号里必须指定列名, 指定列名的函数一般忽略NULL
- 聚集函数可以指定ALL参数或不给参数(因为ALL是默认行为)：对所有行执行计算
- 指定 DISTINCT 参数：只包含不同的值
  * `SELECT AVG(DISTINCT price) AS avg_price FROM 价格表;`
  * 注意：DISTINCT 用于 MAX() 与 MIN() 没有太大意义

## 分组查询
- GROUP BY 常与`聚合函数`与`HAVING`一起搭配
- `聚合函数`: SUM()  AVG()  MAX()  MIN()  COUNT()
- SELECT中的字段名列表,而这些字段名又不在聚合函数中,则应当在`GROUP BY`中列出这些字段名
- GROUP BY 也有 DISTINCT 的去重作用  
  即: `SELECT * FROM GROUP BY 字段1, 字段2, ... (全部字段) `
- 顺序: `SELECT > FROM > WHERE > GROUP BY > HAVING > ORDER BY > LIMIT`
  * GROUP BY 是按'字段'的值分组的
  * ORDER BY 永远放在其他子句之后
  * HAVING 是对 GROUP BY 的分组再过滤
- 区分：  
  * WHERE:  筛选记录; 不可使用聚合函数; 可以出现任意字段
  * HAVING: 筛选组(where过滤行, having过滤分组); 可用聚合函数; 只出现 SELECT 中字段`(或只出现 GROUP BY 中; 或聚合函数中的字段)`
- 例子：
  * `SELECT id, COUNT(*) AS num FROM 价格表 GROUP BY id;`
    - `GROUP BY` 导致不是整个表计算num一次,而是按id不同各自计算它们的num
    - 筛选结果
      |id|num|
      |-|-|
      |1001|3|
      |1002|2|
      |1003|7|
  * `SELECT id, COUNT(*) AS orders FROM orders GROUP BY id HAVING COUNT(*) >= 2;`

## 嵌套查询（子查询）
- 如：
  ```sql
  SELECT id
  FROM orders
  WHERE num IN (SELECT num
  				  FROM orderitems
  WHERE prod_id = 'TNT2');
  ```
- 如：
  ```sql
  SELECT cust_name,
  	  cust_state,
  	  (SELECT COUNT(*)
  FROM orders
  WHERE orders.cust_id = customers.cust_id) AS orders
  FROM customers
  ORDER BY cust_name;
  ```

## 多表连接
- 笛卡尔积: 表一的每一行都会和表二中的所有行进行连接
- 连接时，可能出现歧义的字段名需要限定表名
### 给表取别名
- `SELECT * FROM 很长很长的表名1 AS a`  /* 是在 FROM 中取别名 */
### INNER JOIN (内部联结) 
- `SELECT * FROM 表1 INNER JOIN 表2 ON 连接规则1`
### 自连接
- 一个表自己和自己联结，一般用来替代子查询
- 比如班上有1个学生数学考了100分，你不知道他是谁，你想知道他的其他学科的成绩
  * 一般写法
    ```sql
    select * from score where student_id=(
      select student_id from score where type='mathematics' and score=100
    )
    ```
  * 自连接写法
    ```sql
    select t1.* from score as t1,score as t2 
      where t1.student_id=t2.student_id and t2.type='mathematics' and t2.score=100
    ```
    ```sql
    select t1.* from score as t1 inner join score as t2 
      on t1.student_id=t2.student_id where t2.type='mathematics' and t2.score=100
    ```
### 内部连接(等值连接)
略
### 自然连接(特殊的内部连接)
- MySQL中已经删除，需要用户自己完成
- 自然连接，即内部连接时，某个字段会出现多次。让出现多次的字段只出现一次，其结果即为自然连接
- 例子
  ```sql
  select a.f1,b.f2 from a,b where a.f3=b.f4           (不推荐这样的写法)
  select a.f1,b.f2 from a inner join b on a.f3=b.f4   (inner关键字可以省略)
  ```
- 注意
  * 不使用`join`时是隐式连接，即笛卡尔积，它没有连接条件，但可以使用`where`进行过滤
  * `on`关键字与`where`效果类似，但`on`是连接条件它发生在连接前，`where`是过滤它发生在连接后
### 外部连接
- 分为`左外连接`与`右外连接`与`全外部连接`
- 例子
  ```
  员工信息表和员工迟到记录表(迟到记录表中只保存有过迟到记录员工的数据)，
  通过员工id进行关联。要查询所有员工的迟到情况。
  使用左外连接的结果会保留未迟到过的员工信息，但在`迟到`栏上值为`NULL`
  而使用内连接，未迟到过的员工信息不会被显示。
  ```
  ```sql
  select a.f1,b.f2 from a left outer join b on a.f3=b.f4    (outer关键字可以省略)
  select a.f1,b.f2 from a right outer join b on a.f3=b.f4   (outer关键字可以省略)
  select a.f1,b.f2 from a full outer join b on a.f3=b.f4    (outer关键字可以省略)
  ```

## 组合查询
- 关键字`UNION`
- 用一个视图来表示两条或两条以上的SELECT语句的查询结果
- UNION中的每个查询必须包含相同的列名、表达式或聚集函数(数据类型可以不同,但必须可以隐式转换)
- `UNION`默认自动去除重复的行,`UNION ALL`则不会去除重复的行
- `ORDER BY`只能出现在最后一个`SELECT`语句，但它会作用于整个最终的查询结果

## 约束与事务
应对并发处理
### 完整性
- 实体完整性: 针对表中行数据（主键不为空或不重复）
- 区域完整性：针对表中列数据（CHECK或数据类型）（例如：年龄只能是1 ~ 120）
- 参照完整性：外键（表与相关联的表的数据的正确）
### 约束
- 主键约束（PRIMARY KEY）
- 外键约束（FOREIGN KEY）
- 唯一约束（UNIQUE）: 与 PRIMARY KEY 区别在于 UNIQUE 在表中可以有多个且可为空
- 检查约束：CHECK
- 非空约束：NOT NULL
